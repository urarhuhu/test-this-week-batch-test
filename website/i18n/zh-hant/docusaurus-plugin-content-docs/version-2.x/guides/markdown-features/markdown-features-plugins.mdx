---
id: plugins
description: Using MDX plugins to expand Docusaurus Markdown functionalities
slug: /markdown-features/plugins
---

# MDX 插件

有時您可能需要擴展或調整 Markdown 語法。例如：

- 如何使用圖片語法嵌入 YouTube 影片（`![](https://youtu.be/yKNxeF4KMsY)`）？
- 如何為獨立成行的連結添加特殊樣式（例如社交卡片樣式）？
- 如何讓每個頁面開頭自動加入版權聲明？

答案就是：建立 MDX 插件！MDX 內建[插件系統](https://mdxjs.com/advanced/plugins/)，可用於自訂 Markdown 檔案如何被解析並轉換為 JSX。MDX 插件有三種典型使用情境：

- 使用現有的 [remark 插件](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#list-of-plugins)或 [rehype 插件](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md#list-of-plugins)；
- 建立 remark/rehype 插件來轉換現有 MDX 語法生成的元素；
- 建立 remark/rehype 插件為 MDX 引入新語法。

如果您試用 [MDX 遊樂場](https://mdx-git-renovate-babel-monorepo-mdx.vercel.app/playground)，會注意到 MDX 轉譯有兩個中間步驟：Markdown 抽象語法樹（MDAST）和超文本抽象語法樹（HAST），最終才輸出 JSX。MDX 插件也分為兩種形式：

- **[Remark](https://github.com/remarkjs/remark/)**：處理 Markdown 抽象語法樹。
- **[Rehype](https://github.com/rehypejs/rehype/)**：處理超文本抽象語法樹。

:::tip

使用插件為專案中最常用的 JSX 元素引入簡潔語法。我們提供的[警告框語法](./markdown-features-admonitions.mdx)也是透過 Remark 插件生成，您可以為自己的使用情境實現類似功能。

:::

## 預設插件 {#default-plugins}

Docusaurus 在 Markdown 處理過程中會注入[一些預設 Remark 插件](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-mdx-loader/src/remark)。這些插件會：

- 生成目錄；
- 為每個標題添加錨點連結；
- 將圖片和連結轉換為 `require()` 調用；
- …

這些都是 Remark 插件的典型應用場景，也可作為您實作自訂插件時的參考。

## 安裝插件 {#installing-plugins}

MDX 插件通常是 npm 套件，因此您可以使用 npm 像安裝其他套件一樣安裝它們。以[數學公式插件](./markdown-features-math-equations.mdx)為例。

```bash npm2yarn
npm install --save remark-math@3 rehype-katex@4
```

:::note

近期 Remark/Rehype 生態系統有遷移至 ES Modules（JavaScript 新模組系統）的趨勢，但 Docusaurus 尚未支援。在我們正式支援 ESM 前，請確認安裝的插件版本相容於 CommonJS。或者，您可參考安裝 [`rehype-katex`](./markdown-features-math-equations.mdx#upgrading-rehype-katex-beyond-recommended-version) 的教學，使用動態 `import()` 作為臨時解決方案。

:::

<details>
  <summary>How are <code>remark-math</code> and <code>rehype-katex</code> different?</summary>

In case you are wondering how Remark and Rehype are different, here is a good example. `remark-math` operates on the Markdown AST, where it sees text like `$...$`, and all it does is transform that to the JSX `<span class="math math-inline">...</span>` without doing too much with the content. This decouples the extraction of math formulae from their rendering, which means you can swap $\KaTeX$ out with other math renderers, like MathJax (with [`rehype-mathjax`](https://github.com/remarkjs/remark-math/tree/main/packages/rehype-mathjax)), just by replacing the Rehype plugin.

Next, the `rehype-katex` operates on the Hypertext AST where everything has been converted to HTML-like tags already. It traverses all the elements with `math` class and uses $\KaTeX$ to parse and render the content to actual HTML.

</details>

接著，在 `docusaurus.config.js` 中透過插件或預設配置將它們加入選項：

```js title="docusaurus.config.js"
// highlight-start
const math = require('remark-math');
const katex = require('rehype-katex');
// highlight-end

module.exports = {
  title: 'Docusaurus',
  tagline: 'Build optimized websites quickly, focus on your content',
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-start
          remarkPlugins: [math],
          rehypePlugins: [katex],
          // highlight-end
        },
      },
    ],
  ],
};
```

## 配置插件 {#configuring-plugins}

部分插件可接受自訂配置選項。此時請使用 `[插件, 插件選項]` 語法，如下所示：

```js title="docusaurus.config.js"
module.exports = {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          remarkPlugins: [math],
          rehypePlugins: [
            // highlight-next-line
            [katex, {strict: false}],
          ],
        },
      },
    ],
  ],
};
```

您應查閱插件文件以了解其支援的選項。

## 建立新的 rehype/remark 插件 {#creating-new-rehyperemark-plugins}

如果現有的套件無法滿足你的客製化需求，你可以自行建立 MDX 外掛程式。

:::note

以下說明**並非**建立外掛程式的完整指南，僅展示如何讓其與 Docusaurus 協同運作。如需更深入的運作原理說明，請參閱 [Remark](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#creating-plugins) 或 [Rehype](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#creating-plugins) 的官方文件。

:::

舉例來說，我們建立一個會遍歷所有 `h2` 標題並加上 `第 X 節. ` 前綴的外掛程式。首先，在任何位置建立外掛程式原始檔——你甚至可以將其發佈為獨立的 npm 套件並如前述方式安裝。我們將外掛程式放在 `src/remark/section-prefix.js`。remark/rehype 外掛程式本質上是一個接收 `options` 並返回用於操作 AST 的 `transformer` 的函式。

```js "src/remark/section-prefix.js"
const visit = require('unist-util-visit');

const plugin = (options) => {
  const transformer = async (ast) => {
    let number = 1;
    visit(ast, 'heading', (node) => {
      if (node.depth === 2 && node.children.length > 0) {
        node.children.unshift({
          type: 'text',
          value: `Section ${number}. `,
        });
        number++;
      }
    });
  };
  return transformer;
};

module.exports = plugin;
```

現在你可以在 `docusaurus.config.js` 中導入這個外掛程式，並像使用已安裝的外掛程式一樣使用它！

```js title="docusaurus.config.js"
// highlight-next-line
const sectionPrefix = require('./src/remark/section-prefix');

module.exports = {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-next-line
          remarkPlugins: [sectionPrefix],
        },
      },
    ],
  ],
};
```

:::tip

`transformer` 函式有第二個參數 [`vfile`](https://github.com/vfile/vfile)，當你需要存取當前 Markdown 檔案的路徑時非常有用。

```js
const plugin = (options) => {
  const transformer = async (ast, vfile) => {
    ast.children.unshift({
      type: 'text',
      value: `當前檔案路徑為 ${vfile.path}`,
    });
  };
  return transformer;
};
```

我們的 `transformImage` 外掛程式就使用了此參數，例如將相對路徑的圖片引用轉換為 `require()` 呼叫。

:::

:::note

Docusaurus 的預設外掛程式會先於自訂的 remark 外掛程式執行，這意味著圖片或連結已被轉換為帶有 `require()` 呼叫的 JSX。例如在上面的範例中，即使所有 `h2` 標題都加上了 `第 X 節. ` 前綴，生成的目錄仍保持原樣，因為 TOC 生成外掛程式在我們的自訂外掛程式之前執行。若你需要在預設外掛程式處理前操作 MDAST，請使用 `beforeDefaultRemarkPlugins` 和 `beforeDefaultRehypePlugins`。

```js title="docusaurus.config.js"
module.exports = {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-next-line
          beforeDefaultRemarkPlugins: [sectionPrefix],
        },
      },
    ],
  ],
};
```

這樣生成的目錄也會包含 `第 X 節. ` 前綴。

:::