---
slug: /versioning
---

# Versioning

You can use the versioning CLI to create a new documentation version based on the latest content in the `docs` directory. That specific set of documentation will then be preserved and accessible even as the documentation in the `docs` directory continues to evolve.

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

:::warning

Think about it before starting to version your documentation - it can become difficult for contributors to help improve it!

:::

Most of the time, you don't need versioning as it will just increase your build time, and introduce complexity to your codebase. Versioning is **best suited for websites with high-traffic and rapid changes to documentation between versions**. If your documentation rarely changes, don't add versioning to your documentation.

To better understand how versioning works and see if it suits your needs, you can read on below.

## Overview {#overview}

A typical versioned doc site looks like below:

```bash
website
├── sidebars.json        # sidebar for the current docs version
├── docs                 # docs directory for the current docs version
│   ├── foo
│   │   └── bar.md       # https://mysite.com/docs/next/foo/bar
│   └── hello.md         # https://mysite.com/docs/next/hello
├── versions.json        # file to indicate what versions are available
├── versioned_docs
│   ├── version-1.1.0
│   │   ├── foo
│   │   │   └── bar.md   # https://mysite.com/docs/foo/bar
│   │   └── hello.md
│   └── version-1.0.0
│       ├── foo
│       │   └── bar.md   # https://mysite.com/docs/1.0.0/foo/bar
│       └── hello.md
├── versioned_sidebars
│   ├── version-1.1.0-sidebars.json
│   └── version-1.0.0-sidebars.json
├── docusaurus.config.js
└── package.json
```

The `versions.json` file is a list of version names, ordered from newest to oldest.

The table below explains how a versioned file maps to its version and the generated URL.

| Path                                    | Version        | URL               |
| --------------------------------------- | -------------- | ----------------- |
| `versioned_docs/version-1.0.0/hello.md` | 1.0.0          | /docs/1.0.0/hello |
| `versioned_docs/version-1.1.0/hello.md` | 1.1.0 (latest) | /docs/hello       |
| `docs/hello.md`                         | current        | /docs/next/hello  |

:::tip

The files in the `docs` directory belong to the `current` docs version.

By default, the `current` docs version is labeled as `Next` and hosted under `/docs/next/*`, but it is entirely configurable to fit your project's release lifecycle.

:::

### Terminology {#terminology}

Note the terminology we use here.

<dl>
  <dt>
    <b>Current version</b>
  </dt>
  <dd>
    {'The version placed in the '}
    <code>./docs</code>
    {' folder.'}
  </dd>
  <dt>
    <b>Latest version / last version</b>
  </dt>
  <dd>
    {'The version served by default for docs navbar items. Usually has path '}
    <code>/docs</code>
    {'.'}
  </dd>
</dl>

Current version is defined by the **file system location**, while latest version is defined by the **the navigation behavior**. They may or may not be the same version! (And the default configuration, as shown in the table above, would treat them as different: current version at `/docs/next` and latest at `/docs`.)

## Tutorials {#tutorials}

### Tagging a new version {#tagging-a-new-version}

1. First, make sure the current docs version (the `./docs` directory) is ready to be frozen.
2. Enter a new version number.

```bash npm2yarn
npm run docusaurus docs:version 1.1.0
```

When tagging a new version, the document versioning mechanism will:

- Copy the full `docs/` folder contents into a new `versioned_docs/version-[versionName]/` folder.
- Create a versioned sidebars file based from your current [sidebar](./sidebar/index.mdx) configuration (if it exists) - saved as `versioned_sidebars/version-[versionName]-sidebars.json`.
- Append the new version number to `versions.json`.

### Creating new docs {#creating-new-docs}

1. Place the new file into the corresponding version folder.
2. Include the reference to the new file in the corresponding sidebar file according to the version number.

```mdx-code-block
<Tabs>
<TabItem value="Current version structure">
```

```bash
# The new file.
docs/new.md

# Edit the corresponding sidebar file.
sidebars.js
```

```mdx-code-block
</TabItem>
<TabItem value="Older version structure">
```

```bash
# The new file.
versioned_docs/version-1.0.0/new.md

# Edit the corresponding sidebar file.
versioned_sidebars/version-1.0.0-sidebars.json
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Updating an existing version {#updating-an-existing-version}

You can update multiple docs versions at the same time because each directory in `versioned_docs/` represents specific routes when published.

1. Edit any file.
2. Commit and push changes.
3. It will be published to the version.

Example: When you change any file in `versioned_docs/version-2.6/`, it will only affect the docs for version `2.6`.

### Deleting an existing version {#deleting-an-existing-version}

你也可以刪除/移除版本。

1. 從 `versions.json` 中移除該版本。

範例：

```diff
[
  "2.0.0",
  "1.9.0",
  // highlight-next-line
- "1.8.0"
]
```

2. 刪除版本化文件目錄。範例：`versioned_docs/version-1.8.0`。
3. 刪除版本化側邊欄文件。範例：`versioned_sidebars/version-1.8.0-sidebars.json`。

## 配置版本化行為 {#configuring-versioning-behavior}

「當前」版本是指 `./docs` 文件夾的版本名稱。版本化管理有多種方式，但兩種非常常見的模式是：

- 你發布了 v1，並立即開始開發 v2（包括其文檔）。在這種情況下，**當前版本**是 v2，位於 `./docs` 源文件夾中，可以在 `example.com/docs/next` 瀏覽。**最新版本**是 v1，位於 `./versioned_docs/version-1` 源文件夾中，大多數用戶會在 `example.com/docs` 瀏覽。
- 你發布了 v1，並將在一段時間內維護它，然後才考慮 v2。在這種情況下，**當前版本**和**最新版本**都指向 v1，因為 v2 文檔甚至還不存在！

Docusaurus 的默認設置非常適合第一種使用場景。我們會將當前版本標記為「next」，你甚至可以選擇不發布它。

**對於第二種使用場景**：如果你發布了 v1 並且不打算很快開發 v2，與其將 v1 版本化並必須在兩個文件夾（`./docs` + `./versioned_docs/version-1.0.0`）中維護文檔，你可以考慮「假裝」當前版本是一個已切割的版本，通過為其指定路徑和標籤：

```js title="docusaurus.config.js"
module.exports = {
  presets: [
    '@docusaurus/preset-classic',
    docs: {
      // highlight-start
      lastVersion: 'current',
      versions: {
        current: {
          label: '1.0.0',
          path: '1.0.0',
        },
      },
      // highlight-end
    },
  ],
};
```

`./docs` 中的文檔將在 `/docs/1.0.0` 而不是 `/docs/next` 提供服務，`1.0.0` 將成為我們在導航欄下拉菜單中鏈接的默認版本，而你只需要維護一個 `./docs` 文件夾。

我們提供以下插件選項來自定義版本化行為：

- `disableVersioning`：即使有版本也明確禁用版本化。這將使網站僅包含當前版本。
- `includeCurrentVersion`：包含當前版本（`./docs` 文件夾）的文檔。
  - **提示**：如果當前版本是進行中的工作，尚未準備好發布，請關閉此選項。
- `lastVersion`：設置「最新版本」（`/docs` 路由）指向哪個版本。
  - **提示**：`lastVersion: 'current'` 適用於當前版本指向一個不斷修補和發布的主要版本。最新版本的實際路由基礎路徑和標籤是可配置的。
- `onlyIncludeVersions`：定義從 `versions.json` 中部署的版本子集。
  - **提示**：在開發和部署預覽中限制為 2 或 3 個版本，以提高啟動和構建時間。
- `versions`：版本元數據的字典。對於每個版本，你可以自定義以下內容：
  - `label`：在版本下拉菜單和橫幅中顯示的標籤。
  - `path`：此版本的路由基礎路徑。默認情況下，最新版本有 `/`，當前版本有 `/next`。
  - `banner`：`'none'`、`'unreleased'` 或 `'unmaintained'` 之一。決定每個文檔頁面頂部顯示的內容。任何高於最新版本的版本將是「unreleased」，任何低於的版本將是「unmaintained」。
  - `badge`：在該版本的文檔頂部顯示帶有版本名稱的徽章。
  - `className`：為該版本的文檔頁面的 `<html>` 元素添加自定義 `className`。

詳見[文檔插件配置](../../api/plugins/plugin-content-docs.mdx#configuration)。

## 導航欄項目 {#navbar-items}

我們提供多個導航欄項目，幫助你快速設置導航，無需擔心版本化路由。

- [`doc`](../../api/themes/theme-configuration.mdx#navbar-doc-link): 指向文檔的連結。
- [`docSidebar`](../../api/themes/theme-configuration.mdx#navbar-doc-sidebar): 指向側邊欄中第一個項目的連結。
- [`docsVersion`](../../api/themes/theme-configuration.mdx#navbar-docs-version): 指向當前查看版本的主要文檔的連結。
- [`docsVersionDropdown`](../../api/themes/theme-configuration.mdx#navbar-docs-version-dropdown): 包含所有可用版本的下拉選單。

這些連結會按照以下順序尋找合適的版本進行連結：

1. **當前版本**：如果用戶正在瀏覽由該文檔插件提供的頁面，則為用戶當前瀏覽的版本。如果用戶不在文檔頁面上，則退而求其次...
2. **偏好版本**：用戶上次查看的版本。如果沒有歷史記錄，則退而求其次...
3. **最新版本**：由 `lastVersion` 選項配置的預設版本。

## 推薦做法 {#recommended-practices}

### 僅在需要時對文檔進行版本控制 {#version-your-documentation-only-when-needed}

例如，您正在為您的 npm 套件 `foo` 構建文檔，當前版本為 1.0.0。然後您發布了一個修復小錯誤的補丁版本，現在是 1.0.1。

您應該為文檔創建一個新版本 1.0.1 嗎？**可能不需要**。根據語意化版本控制，1.0.1 和 1.0.0 的文檔不應該有差異，因為沒有新增功能！為此創建新版本只會產生不必要的重複文件。

### 保持版本數量較少 {#keep-the-number-of-versions-small}

作為一個好的經驗法則，嘗試將版本數量保持在 10 個以下。您**很可能**會有很多過時的版本化文檔，甚至沒有人會閱讀。例如，[Jest](https://jestjs.io/versions) 當前版本為 `27.4`，僅維護幾個最新的文檔版本，最低版本為 `25.X`。保持數量較少 😊

:::tip[封存舊版本]

如果您在 Jamstack 提供商（例如 [Netlify](../../deployment.mdx)）上部署您的網站，該提供商會將每個生產構建保存為不可變 URL 下的快照。您可以將不再重建的封存版本作為外部連結添加到這些不可變 URL。Jest 網站和 Docusaurus 網站都使用這種模式來保持主動構建的版本數量較低。

:::

### 在文檔中使用絕對導入 {#use-absolute-import-within-the-docs}

不要在文檔中使用相對路徑導入。因為當我們創建版本時，這些路徑將不再有效（嵌套級別不同，以及其他原因）。您可以使用 Docusaurus 提供的 `@site` 別名，它指向 `website` 目錄。例如：

```diff
- import Foo from '../src/components/Foo';
+ import Foo from '@site/src/components/Foo';
```

### 通過文件路徑連結文檔 {#link-docs-by-file-paths}

通過帶有 `.md` 副檔名的相對文件路徑引用其他文檔，這樣 Docusaurus 可以在構建期間將它們重寫為實際的 URL 路徑。文件將連結到正確的對應版本。

```md
The [@hello](hello.mdx#paginate) document is great!

See the [Tutorial](../getting-started/tutorial.mdx) for more info.
```

### 全局或版本化的共置資源 {#global-or-versioned-collocated-assets}

您應該決定資源（如圖片和文件）是按版本劃分還是在版本之間共享。

如果您的資源應該是版本化的，請將它們放在文檔版本中，並使用相對路徑：

```md
![img alt](./myImage.png)

[download this file](./file.pdf)
```

如果您的資源是全局的，請將它們放在 `/static` 中並使用絕對路徑：

```md
![img alt](/myImage.png)

[download this file](/file.pdf)
```