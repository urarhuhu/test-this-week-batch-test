---
id: plugins
description: Using MDX plugins to expand Docusaurus Markdown functionalities
slug: /markdown-features/plugins
---

# MDX 插件

有時，您可能希望擴展或調整 Markdown 語法。例如：

- 如何使用圖片語法嵌入 YouTube 影片（`![](https://youtu.be/yKNxeF4KMsY)`）？
- 如何為獨立一行的連結設定不同樣式，例如社交卡片？
- 如何讓每個頁面開頭都顯示版權聲明？

答案是：建立一個 MDX 插件！MDX 內建了[插件系統](https://mdxjs.com/advanced/plugins/)，可用於自訂 Markdown 檔案如何被解析並轉換為 JSX。MDX 插件有三種典型使用情境：

- 使用現有的 [remark 插件](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#list-of-plugins)或 [rehype 插件](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md#list-of-plugins)；
- 建立 remark/rehype 插件來轉換現有 MDX 語法生成的元素；
- 建立 remark/rehype 插件來為 MDX 引入新語法。

如果您試用 [MDX 遊樂場](https://mdxjs.com/playground/)，會注意到 MDX 轉譯有兩個中間步驟：Markdown 抽象語法樹（MDAST）和超文本抽象語法樹（HAST），最終才輸出為 JSX。MDX 插件也有兩種形式：

- **[Remark](https://github.com/remarkjs/remark/)**：處理 Markdown 抽象語法樹。
- **[Rehype](https://github.com/rehypejs/rehype/)**：處理超文本抽象語法樹。

:::tip

使用插件為專案中最常用的 JSX 元素引入簡潔語法。我們提供的[ admonition 語法](./markdown-features-admonitions.mdx)也是由 Remark 插件生成，您可以為自己的使用情境實現類似功能。

:::

## 預設插件 {#default-plugins}

Docusaurus 在 Markdown 處理過程中會注入[一些預設的 Remark 插件](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-mdx-loader/src/remark)。這些插件會：

- 生成目錄；
- 為每個標題添加錨點連結；
- 將圖片和連結轉換為 `require()` 調用。
- …

這些都是 Remark 插件的典型應用場景，也可作為您實現自訂插件時的靈感來源。

## 安裝插件 {#installing-plugins}

MDX 插件通常是 npm 套件，因此您可以使用 npm 像安裝其他套件一樣安裝它們。以[數學公式插件](./markdown-features-math-equations.mdx)為例。

```bash npm2yarn
npm install --save remark-math@5 rehype-katex@6
```

<details>
  <summary>How are <code>remark-math</code> and <code>rehype-katex</code> different?</summary>

In case you are wondering how Remark and Rehype are different, here is a good example. `remark-math` operates on the Markdown AST, where it sees text like `$...$`, and all it does is transform that to the JSX `<span class="math math-inline">...</span>` without doing too much with the content. This decouples the extraction of math formulae from their rendering, which means you can swap $\KaTeX$ out with other math renderers, like MathJax (with [`rehype-mathjax`](https://github.com/remarkjs/remark-math/tree/main/packages/rehype-mathjax)), just by replacing the Rehype plugin.

Next, the `rehype-katex` operates on the Hypertext AST where everything has been converted to HTML-like tags already. It traverses all the elements with `math` class and uses $\KaTeX$ to parse and render the content to actual HTML.

</details>

:::warning

許多官方 Remark/Rehype 插件僅支援[**ES Modules**](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)，這是 JavaScript 的模組系統，Docusaurus 也支援此格式。建議使用[**ES Modules**](https://flaviocopes.com/es-modules/) 設定檔，以便更輕鬆地導入這類套件。

:::

接著，導入您的插件並透過 `docusaurus.config.js` 中的插件或預設配置將其添加到插件選項：

```js title="docusaurus.config.js"
// highlight-start
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
// highlight-end

// highlight-start
export default {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          path: 'docs',
          // highlight-start
          remarkPlugins: [remarkMath],
          rehypePlugins: [rehypeKatex],
          // highlight-end
        },
      },
    ],
  ],
};
```

<details>
  <summary>Using a [**CommonJS**](https://nodejs.org/api/modules.html#modules-commonjs-modules) config file?</summary>

If you decide to use a CommonJS config file, it is possible to load those ES module plugins thanks to dynamic imports and an async config creator function:

```js title="docusaurus.config.js"
// highlight-start
module.exports = async function createConfigAsync() {
  // highlight-end
  return {
    presets: [
      [
        '@docusaurus/preset-classic',
        {
          docs: {
            path: 'docs',
            // highlight-start
            remarkPlugins: [(await import('remark-math')).default],
            rehypePlugins: [(await import('rehype-katex')).default],
            // highlight-end
          },
        },
      ],
    ],
  };
};
```

</details>

## 配置插件 {#configuring-plugins}

部分插件可進行配置並接受自己的選項。此時，請使用 `[plugin, pluginOptions]` 語法，如下所示：

```js title="docusaurus.config.js"
import rehypeKatex from 'rehype-katex';

export default {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          rehypePlugins: [
            // highlight-start
            [rehypeKatex, {strict: false}],
            // highlight-end
          ],
        },
      },
    ],
  ],
};
```

您應查閱插件的文件以了解其支援的選項。

## 建立新的 rehype/remark 插件 {#creating-new-rehyperemark-plugins}

If there isn't an existing package that satisfies your customization need, you can create your own MDX plugin.

:::note

The writeup below is **not** meant to be a comprehensive guide to creating a plugin, but just an illustration of how to make it work with Docusaurus. Visit the [Remark](https://github.com/remarkjs/remark/blob/main/doc/plugins.md#create-plugins) or [Rehype](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md#create-plugins) documentation for a more in-depth explanation of how they work.

:::

For example, let's make a plugin that visits every `h2` heading and adds a `Section X. ` prefix. First, create your plugin source file anywhere—you can even publish it as a separate npm package and install it like explained above. We would put ours at `src/remark/section-prefix.js`. A remark/rehype plugin is just a function that receives the `options` and returns a `transformer` that operates on the AST.

```js "src/remark/section-prefix.js"
import {visit} from 'unist-util-visit';

const plugin = (options) => {
  const transformer = async (ast) => {
    let number = 1;
    visit(ast, 'heading', (node) => {
      if (node.depth === 2 && node.children.length > 0) {
        node.children.unshift({
          type: 'text',
          value: `Section ${number}. `,
        });
        number++;
      }
    });
  };
  return transformer;
};

export default plugin;
```

You can now import your plugin in `docusaurus.config.js` and use it just like an installed plugin!

```js title="docusaurus.config.js"
// highlight-next-line
import sectionPrefix from './src/remark/section-prefix';

export default {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-next-line
          remarkPlugins: [sectionPrefix],
        },
      },
    ],
  ],
};
```

:::tip

The `transformer` has a second parameter [`vfile`](https://github.com/vfile/vfile) which is useful if you need to access the current Markdown file's path.

```js
const plugin = (options) => {
  const transformer = async (ast, vfile) => {
    ast.children.unshift({
      type: 'text',
      value: `The current file path is ${vfile.path}`,
    });
  };
  return transformer;
};
```

Our `transformImage` plugin uses this parameter, for example, to transform relative image references to `require()` calls.

:::

:::note

The default plugins of Docusaurus would operate before the custom remark plugins, and that means the images or links have been converted to JSX with `require()` calls already. For example, in the example above, the table of contents generated is still the same even when all `h2` headings are now prefixed by `Section X.`, because the TOC-generating plugin is called before our custom plugin. If you need to process the MDAST before the default plugins do, use the `beforeDefaultRemarkPlugins` and `beforeDefaultRehypePlugins`.

```js title="docusaurus.config.js"
export default {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-next-line
          beforeDefaultRemarkPlugins: [sectionPrefix],
        },
      },
    ],
  ],
};
```

This would make the table of contents generated contain the `Section X.` prefix as well.

:::