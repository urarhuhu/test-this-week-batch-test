---
sidebar_position: 1
toc_max_heading_level: 4
---

# Lifecycle APIs

During the build, plugins are loaded in parallel to fetch their own contents and render them to routes. Plugins may also configure webpack or post-process the generated files.

## `async loadContent()` {#loadContent}

Plugins should use this lifecycle to fetch from data sources (filesystem, remote API, headless CMS, etc.) or do some server processing. The return value is the content it needs.

For example, this plugin below returns a random integer between 1 and 10 as content.

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'docusaurus-plugin',
    // highlight-start
    async loadContent() {
      return 1 + Math.floor(Math.random() * 10);
    },
    // highlight-end
  };
}
```

## `async contentLoaded({content, actions})` {#contentLoaded}

The data that was loaded in `loadContent` will be consumed in `contentLoaded`. It can be rendered to routes, registered as global data, etc.

### `content` {#content}

`contentLoaded` will be called _after_ `loadContent` is done. The return value of `loadContent()` will be passed to `contentLoaded` as `content`.

### `actions` {#actions}

`actions` contain three functions:

#### `addRoute(config: RouteConfig): void` {#addRoute}

Create a route to add to the website.

```ts
export type RouteConfig = {
  /**
   * With leading slash. Trailing slash will be normalized by config.
   */
  path: string;
  /**
   * Component used to render this route, a path that the bundler can `require`.
   */
  component: string;
  /**
   * Props. Each entry should be `[propName]: pathToPropModule` (created with
   * `createData`)
   */
  modules?: RouteModules;
  /**
   * The route context will wrap the `component`. Use `useRouteContext` to
   * retrieve what's declared here. Note that all custom route context declared
   * here will be namespaced under {@link RouteContext.data}.
   */
  context?: RouteModules;
  /**
   * Nested routes config, useful for "layout routes" having subroutes.
   */
  routes?: RouteConfig[];
  /**
   * React router config option: `exact` routes would not match subroutes.
   */
  exact?: boolean;
  /**
   * React router config option: `strict` routes are sensitive to the presence
   * of a trailing slash.
   */
  strict?: boolean;
  /**
   * Used to sort routes.
   * Higher-priority routes will be matched first.
   */
  priority?: number;
  /**
   * Optional route metadata
   */
  metadata?: RouteMetadata;
  /**
   * Extra props; will be available on the client side.
   */
  [propName: string]: unknown;
};

/**
 * Plugin authors can assign extra metadata to the created routes
 * It is only available on the Node.js side, and not sent to the browser
 * Optional: plugin authors are encouraged but not required to provide it
 *
 * Some plugins might use this data to provide additional features.
 * This is the case of the sitemap plugin to provide support for "lastmod".
 * See also: https://github.com/facebook/docusaurus/pull/9954
 */
export type RouteMetadata = {
  /**
   * The source code file path that led to the creation of the current route
   * In official content plugins, this is usually a Markdown or React file
   * This path is expected to be relative to the site directory
   */
  sourceFilePath?: string;
  /**
   * The last updated date of this route
   * This is generally read from the Git history of the sourceFilePath
   * but can also be provided through other means (usually front matter)
   *
   * This has notably been introduced for adding "lastmod" support to the
   * sitemap plugin, see https://github.com/facebook/docusaurus/pull/9954
   */
  lastUpdatedAt?: number;
};

type RouteModules = {
  [module: string]: Module | RouteModules | RouteModules[];
};

type Module =
  | {
      path: string;
      __import?: boolean;
      query?: ParsedUrlQueryInput;
    }
  | string;
```

#### `createData(name: string, data: any): Promise<string>` {#createData}

A declarative callback to create static data (generally JSON or string) which can later be provided to your routes as props. Takes the file name and data to be stored, and returns the actual data file's path.

For example, this plugin below creates a `/friends` page which displays `Your friends are: Yangshun, Sebastien`:

```jsx title="website/src/components/Friends.js"
import React from 'react';

export default function FriendsComponent({friends}) {
  return <div>Your friends are {friends.join(',')}</div>;
}
```

```js title="docusaurus-friends-plugin/src/index.js"
export default function friendsPlugin(context, options) {
  return {
    name: 'docusaurus-friends-plugin',
    // highlight-start
    async contentLoaded({content, actions}) {
      const {createData, addRoute} = actions;
      // Create friends.json
      const friends = ['Yangshun', 'Sebastien'];
      const friendsJsonPath = await createData(
        'friends.json',
        JSON.stringify(friends),
      );

      // Add the '/friends' routes, and ensure it receives the friends props
      addRoute({
        path: '/friends',
        component: '@site/src/components/Friends.js',
        modules: {
          // propName -> JSON file path
          friends: friendsJsonPath,
        },
        exact: true,
      });
    },
    // highlight-end
  };
}
```

#### `setGlobalData(data: any): void` {#setGlobalData}

This function permits one to create some global plugin data that can be read from any page, including the pages created by other plugins, and your theme layout.

This data becomes accessible to your client-side/theme code through the [`useGlobalData`](../../docusaurus-core.mdx#useGlobalData) and [`usePluginData`](../../docusaurus-core.mdx#usePluginData) hooks.

:::warning

Global data is... global: its size affects the loading time of all pages of your site, so try to keep it small. Prefer `createData` and page-specific data whenever possible.

:::

For example, this plugin below creates a `/friends` page which displays `Your friends are: Yangshun, Sebastien`:

```jsx title="website/src/components/Friends.js"
import React from 'react';
import {usePluginData} from '@docusaurus/useGlobalData';

export default function FriendsComponent() {
  const {friends} = usePluginData('docusaurus-friends-plugin');
  return <div>Your friends are {friends.join(',')}</div>;
}
```

```js title="docusaurus-friends-plugin/src/index.js"
export default function friendsPlugin(context, options) {
  return {
    name: 'docusaurus-friends-plugin',
    // highlight-start
    async contentLoaded({content, actions}) {
      const {setGlobalData, addRoute} = actions;
      // Create friends global data
      setGlobalData({friends: ['Yangshun', 'Sebastien']});

      // Add the '/friends' routes
      addRoute({
        path: '/friends',
        component: '@site/src/components/Friends.js',
        exact: true,
      });
    },
    // highlight-end
  };
}
```

## `configureWebpack(config, isServer, utils, content)` {#configureWebpack}

Modifies the internal webpack config. If the return value is a JavaScript object, it will be merged into the final config using [`webpack-merge`](https://github.com/survivejs/webpack-merge). If it is a function, it will be called and receive `config` as the first argument and an `isServer` flag as the second argument.

:::warning

The API of `configureWebpack` will be modified in the future to accept an object (`configureWebpack({config, isServer, utils, content})`)

:::

### `config` {#config}

`configureWebpack` is called with `config` generated according to client/server build. You may treat this as the base config to be merged with.

### `isServer` {#isServer}

`configureWebpack` 會在伺服器建置和客戶端建置時被呼叫。伺服器建置會收到 `true` 作為 `isServer` 參數，而客戶端建置則會收到 `false`。

### `utils` {#utils}

`configureWebpack` 還會收到一個工具物件：

- `getStyleLoaders(isServer: boolean, cssOptions: {[key: string]: any}): Loader[]`
- `getJSLoader(isServer: boolean, cacheOptions?: {}): Loader | null`

你可以使用它們來有條件地回傳你的 webpack 配置。

例如，下面的外掛會修改 webpack 配置來轉譯 `.foo` 檔案。

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'custom-docusaurus-plugin',
    // highlight-start
    configureWebpack(config, isServer, utils) {
      const {getJSLoader} = utils;
      return {
        module: {
          rules: [
            {
              test: /\.foo$/,
              use: [getJSLoader(isServer), 'my-custom-webpack-loader'],
            },
          ],
        },
      };
    },
    // highlight-end
  };
}
```

### `content` {#content-1}

`configureWebpack` 會同時被呼叫並帶入由外掛載入的內容。

### 合併策略 {#merge-strategy}

我們使用 [webpack-merge](https://github.com/survivejs/webpack-merge) 將外掛的 Webpack 配置部分合併到全域 Webpack 配置中。

可以指定合併策略。例如，如果你希望 webpack 規則被前置而非追加：

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'custom-docusaurus-plugin',
    configureWebpack(config, isServer, utils) {
      return {
        // highlight-start
        mergeStrategy: {'module.rules': 'prepend'},
        module: {rules: [myRuleToPrepend]},
        // highlight-end
      };
    },
  };
}
```

詳情請閱讀 [webpack-merge 策略文件](https://github.com/survivejs/webpack-merge#merging-with-strategies)。

### 配置開發伺服器 {#configuring-dev-server}

可以透過回傳一個 `devServer` 欄位來配置開發伺服器。

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'custom-docusaurus-plugin',
    configureWebpack(config, isServer, utils) {
      return {
        // highlight-start
        devServer: {
          open: '/docs', // Opens localhost:3000/docs instead of localhost:3000/
        },
        // highlight-end
      };
    },
  };
}
```

## `configurePostCss(options)` {#configurePostCss}

在生成客戶端套件時修改 [`postcss-loader` 的 `postcssOptions`](https://webpack.js.org/loaders/postcss-loader/#postcssoptions)。

應回傳修改後的 `postcssOptions`。

預設情況下，`postcssOptions` 看起來像這樣：

```js
const postcssOptions = {
  ident: 'postcss',
  plugins: [require('autoprefixer')],
};
```

範例：

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'docusaurus-plugin',
    // highlight-start
    configurePostCss(postcssOptions) {
      // Appends new PostCSS plugin.
      postcssOptions.plugins.push(require('postcss-import'));
      return postcssOptions;
    },
    // highlight-end
  };
}
```

## `postBuild(props)` {#postBuild}

在 (生產) 建置完成時呼叫。

```ts
interface Props {
  siteDir: string;
  generatedFilesDir: string;
  siteConfig: DocusaurusConfig;
  outDir: string;
  baseUrl: string;
  headTags: string;
  preBodyTags: string;
  postBodyTags: string;
  routesPaths: string[];
  plugins: Plugin<any>[];
  content: Content;
}
```

範例：

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'docusaurus-plugin',
    // highlight-start
    async postBuild({siteConfig = {}, routesPaths = [], outDir}) {
      // Print out to console all the rendered routes.
      routesPaths.map((route) => {
        console.log(route);
      });
    },
    // highlight-end
  };
}
```

## `injectHtmlTags({content})` {#injectHtmlTags}

向 Docusaurus 生成的 HTML 注入 head 和/或 body HTML 標籤。

`injectHtmlTags` 會同時被呼叫並帶入由外掛載入的內容。

```ts
function injectHtmlTags(): {
  headTags?: HtmlTags;
  preBodyTags?: HtmlTags;
  postBodyTags?: HtmlTags;
};

type HtmlTags = string | HtmlTagObject | (string | HtmlTagObject)[];

type HtmlTagObject = {
  /**
   * Attributes of the HTML tag
   * E.g. `{'disabled': true, 'value': 'demo', 'rel': 'preconnect'}`
   */
  attributes?: {
    [attributeName: string]: string | boolean;
  };
  /**
   * The tag name e.g. `div`, `script`, `link`, `meta`
   */
  tagName: string;
  /**
   * The inner HTML
   */
  innerHTML?: string;
};
```

範例：

```js title="docusaurus-plugin/src/index.js"
export default function (context, options) {
  return {
    name: 'docusaurus-plugin',
    loadContent: async () => {
      return {remoteHeadTags: await fetchHeadTagsFromAPI()};
    },
    // highlight-start
    injectHtmlTags({content}) {
      return {
        headTags: [
          {
            tagName: 'link',
            attributes: {
              rel: 'preconnect',
              href: 'https://www.github.com',
            },
          },
          ...content.remoteHeadTags,
        ],
        preBodyTags: [
          {
            tagName: 'script',
            attributes: {
              charset: 'utf-8',
              src: '/noflash.js',
            },
          },
        ],
        postBodyTags: [`<div> This is post body </div>`],
      };
    },
    // highlight-end
  };
}
```

標籤將按以下方式添加：

- `headTags` 會在 `</head>` 關閉標籤前插入，位於配置添加的腳本之後。
- `preBodyTags` 會在 `<body>` 開始標籤後插入，位於任何子元素之前。
- `postBodyTags` 會在 `</body>` 關閉標籤前插入，位於所有子元素之後。

## `getClientModules()` {#getClientModules}

回傳要導入客戶端套件的[客戶端模組](../../advanced/client.mdx#client-modules)路徑陣列。

例如，要讓你的主題載入使用者透過 `options` 傳入的 `customCss` 或 `customJs` 檔案路徑：

```js title="my-theme/src/index.js"
export default function (context, options) {
  const {customCss, customJs} = options || {};
  return {
    name: 'name-of-my-theme',
    // highlight-start
    getClientModules() {
      return [customCss, customJs];
    },
    // highlight-end
  };
}
```