---
sidebar_label: Static site generation
description: Docusaurus statically renders your React code into HTML, allowing faster load speed and better SEO.
---

# Static site generation (SSG)

In [architecture](architecture.mdx), we mentioned that the theme is run in Webpack. But beware: that doesn't mean it always has access to browser globals! The theme is built twice:

- During **server-side rendering**, the theme is compiled in a sandbox called [React DOM Server](https://reactjs.org/docs/react-dom-server.html). You can see this as a "headless browser", where there is no `window` or `document`, only React. SSR produces static HTML pages.
- During **client-side rendering**, the theme is compiled to JavaScript that gets eventually executed in the browser, so it has access to browser variables.

:::info[SSR or SSG?]

_Server-side rendering_ and _static site generation_ can be different concepts, but we use them interchangeably.

Strictly speaking, Docusaurus is a static site generator, because there's no server-side runtime—we statically render to HTML files that are deployed on a CDN, instead of dynamically pre-rendering on each request. This differs from the working model of [Next.js](https://nextjs.org/).

:::

Therefore, while you probably know not to access Node globals like `process` ([or can we?](#node-env)) or the `'fs'` module, you can't freely access browser globals either.

```jsx
import React from 'react';

export default function WhereAmI() {
  return <span>{window.location.href}</span>;
}
```

This looks like idiomatic React, but if you run `docusaurus build`, you will get an error:

```
ReferenceError: window is not defined
```

This is because during server-side rendering, the Docusaurus app isn't actually run in browser, and it doesn't know what `window` is.

```mdx-code-block
<details id="node-env">
<summary>What about <code>process.env.NODE_ENV</code>?</summary>
```

One exception to the "no Node globals" rule is `process.env.NODE_ENV`. In fact, you can use it in React, because Webpack injects this variable as a global:

```jsx
import React from 'react';

export default function expensiveComp() {
  if (process.env.NODE_ENV === 'development') {
    return <>This component is not shown in development</>;
  }
  const res = someExpensiveOperationThatLastsALongTime();
  return <>{res}</>;
}
```

During Webpack build, the `process.env.NODE_ENV` will be replaced with the value, either `'development'` or `'production'`. You will then get different build results after dead code elimination:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

```mdx-code-block
<Tabs>
<TabItem value="Development">
```

```diff
import React from 'react';

export default function expensiveComp() {
  // highlight-next-line
  if ('development' === 'development') {
+   return <>This component is not shown in development</>;
  }
- const res = someExpensiveOperationThatLastsALongTime();
- return <>{res}</>;
}
```

```mdx-code-block
</TabItem>
<TabItem value="Production">
```

```diff
import React from 'react';

export default function expensiveComp() {
  // highlight-next-line
- if ('production' === 'development') {
-   return <>This component is not shown in development</>;
- }
+ const res = someExpensiveOperationThatLastsALongTime();
+ return <>{res}</>;
}
```

```mdx-code-block
</TabItem>
</Tabs>
</details>
```

## Understanding SSR {#understanding-ssr}

React is not just a dynamic UI runtime—it's also a templating engine. Because Docusaurus sites mostly contain static contents, it should be able to work without any JavaScript (which React runs in), but only plain HTML/CSS. And that's what server-side rendering offers: statically rendering your React code into HTML, without any dynamic content. An HTML file has no concept of client state (it's purely markup), hence it shouldn't rely on browser APIs.

These HTML files are the first to arrive at the user's browser screen when a URL is visited (see [routing](routing.mdx)). Afterwards, the browser fetches and runs other JS code to provide the "dynamic" parts of your site—anything implemented with JavaScript. However, before that, the main content of your page is already visible, allowing faster loading.

In CSR-only apps, all DOM elements are generated on client side with React, and the HTML file only ever contains one root element for React to mount DOM to; in SSR, React is already facing a fully built HTML page, and it only needs to correlate the DOM elements with the virtual DOM in its model. This step is called "hydration". After React has hydrated the static markup, the app starts to work as any normal React app.

請注意，Docusaurus 本質上是一個單頁應用程式，因此靜態網站生成僅是一種優化（稱為_漸進增強_），但我們的功能並不完全依賴這些 HTML 檔案。這與 [Jekyll](https://jekyllrb.com/) 和 [Docusaurus v1](https://v1.docusaurus.io/) 等網站生成器不同，後者的所有檔案都會靜態轉換為標記，並通過 `<script>` 標籤連結的外部 JavaScript 添加互動性。如果您檢查建置輸出，仍然會看到 `build/assets/js` 下的 JS 資源，這些才是 Docusaurus 的核心。

## 逃生艙機制 {#escape-hatches}

如果您需要在畫面上渲染任何依賴瀏覽器 API 才能正常運作的動態內容，例如：

- 我們的[互動式代碼區塊](../guides/markdown-features/markdown-features-code-blocks.mdx#interactive-code-editor)，它在瀏覽器的 JS 運行時中執行
- 我們的[主題化圖片](../guides/markdown-features/markdown-features-assets.mdx#themed-images)，它會檢測用戶的色彩方案以顯示不同的圖片
- 我們調試面板的 JSON 檢視器，它使用 `window` 全域變數進行樣式設定

您可能需要避開 SSR，因為靜態 HTML 在不知道客戶端狀態的情況下無法顯示任何有用的內容。

:::warning

客戶端的首次渲染必須產生與伺服器端渲染完全相同的 DOM 結構，這一點非常重要，否則 React 會將虛擬 DOM 與錯誤的 DOM 元素關聯起來。

因此，單純使用 `if (typeof window !== 'undefined) {/* 渲染某些內容 */}` 作為瀏覽器與伺服器的檢測方法並不合適，因為客戶端的首次渲染會立即產生與伺服器生成的不同標記。

您可以在 [The Perils of Rehydration](https://www.joshwcomeau.com/react/the-perils-of-rehydration/) 中閱讀更多關於這個陷阱的資訊。

:::

我們提供了幾種更可靠的 SSR 逃生方法。

### `<BrowserOnly>` {#browseronly}

如果您需要在瀏覽器中渲染某些元件（例如，因為該元件依賴瀏覽器特定功能才能正常運作），常見的方法是將您的元件包裝在 [`<BrowserOnly>`](../docusaurus-core.mdx#browseronly) 中，以確保它在 SSR 期間不可見，僅在 CSR 中渲染。

```jsx
import BrowserOnly from '@docusaurus/BrowserOnly';

function MyComponent(props) {
  return (
    // highlight-start
    <BrowserOnly fallback={<div>Loading...</div>}>
      {() => {
        const LibComponent =
          require('some-lib-that-accesses-window').LibComponent;
        return <LibComponent {...props} />;
      }}
    </BrowserOnly>
    // highlight-end
  );
}
```

重要的是要理解，`<BrowserOnly>` 的子元素不是 JSX 元素，而是一個_返回_元素的函數。這是一個設計決策。考慮以下代碼：

```jsx
import BrowserOnly from '@docusaurus/BrowserOnly';

function MyComponent() {
  return (
    <BrowserOnly>
      {/* highlight-start */}
      {/* DON'T DO THIS - doesn't actually work */}
      <span>page url = {window.location.href}</span>
      {/* highlight-end */}
    </BrowserOnly>
  );
}
```

雖然您可能期望 `BrowserOnly` 在伺服器端渲染時隱藏子元素，但實際上它無法做到。當 React 渲染器嘗試渲染這個 JSX 樹時，它確實會將 `{window.location.href}` 變量視為該樹的一個節點並嘗試渲染它，儘管它實際上並未被使用！使用函數可以確保我們僅在需要時才讓渲染器看到瀏覽器專用的元件。

### `useIsBrowser` {#useisbrowser}

您也可以使用 `useIsBrowser()` 鉤子來測試元件當前是否處於瀏覽器環境中。它在 SSR 中返回 `false`，在首次客戶端渲染後的 CSR 中返回 `true`。如果您只需要在客戶端執行某些條件操作，而不是渲染完全不同的 UI，可以使用此鉤子。

```jsx
import useIsBrowser from '@docusaurus/useIsBrowser';

function MyComponent() {
  const isBrowser = useIsBrowser();
  const location = isBrowser ? window.location.href : 'fetching location...';
  return <span>{location}</span>;
}
```

### `useEffect` {#useeffect}

最後，您可以將邏輯放在 `useEffect()` 中，以延遲其執行直到首次 CSR 之後。這最適合僅執行副作用但不_獲取_客戶端狀態數據的情況。

```jsx
function MyComponent() {
  useEffect(() => {
    // Only logged in the browser console; nothing is logged during server-side rendering
    console.log("I'm now in the browser");
  }, []);
  return <span>Some content...</span>;
}
```

### `ExecutionEnvironment` {#executionenvironment}

[`ExecutionEnvironment`](../docusaurus-core.mdx#executionenvironment) 命名空間包含多個值，其中 `canUseDOM` 是檢測瀏覽器環境的有效方法。

請注意，它本質上是在底層檢查 `typeof window !== 'undefined'`，因此不應將其用於渲染相關邏輯，而僅適用於命令式代碼，例如透過發送網路請求來響應用戶輸入，或動態載入函式庫（這些操作完全不會更新 DOM）。

```js title="a-client-module.js"
import ExecutionEnvironment from '@docusaurus/ExecutionEnvironment';

if (ExecutionEnvironment.canUseDOM) {
  document.title = "I'm loaded!";
}
```