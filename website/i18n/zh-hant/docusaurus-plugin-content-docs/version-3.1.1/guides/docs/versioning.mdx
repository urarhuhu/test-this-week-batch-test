---
slug: /versioning
---

# 版本控制

您可以使用版本控制 CLI 基於 `docs` 目錄中的最新內容創建新的文檔版本。該特定文檔集將被保留並可訪問，即使 `docs` 目錄中的文檔持續演進。

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

:::warning

在開始對文檔進行版本控制之前請三思——這可能會使貢獻者難以協助改進文檔！

:::

大多數情況下，您不需要版本控制，因為這只會增加構建時間，並為代碼庫引入複雜性。版本控制**最適合文檔流量高且版本間文檔變化迅速的網站**。如果您的文檔很少變更，請勿為文檔添加版本控制。

要更好地理解版本控制的工作原理並判斷其是否適合您的需求，您可以繼續閱讀下文。

## 概述 {#overview}

典型的版本化文檔網站結構如下：

```bash
website
├── sidebars.json        # sidebar for the current docs version
├── docs                 # docs directory for the current docs version
│   ├── foo
│   │   └── bar.md       # https://mysite.com/docs/next/foo/bar
│   └── hello.md         # https://mysite.com/docs/next/hello
├── versions.json        # file to indicate what versions are available
├── versioned_docs
│   ├── version-1.1.0
│   │   ├── foo
│   │   │   └── bar.md   # https://mysite.com/docs/foo/bar
│   │   └── hello.md
│   └── version-1.0.0
│       ├── foo
│       │   └── bar.md   # https://mysite.com/docs/1.0.0/foo/bar
│       └── hello.md
├── versioned_sidebars
│   ├── version-1.1.0-sidebars.json
│   └── version-1.0.0-sidebars.json
├── docusaurus.config.js
└── package.json
```

`versions.json` 文件是一個版本名稱列表，按從新到舊的順序排列。

下表解釋了版本化文件如何映射到其版本及生成的 URL。

| Path                                    | Version        | URL               |
| --------------------------------------- | -------------- | ----------------- |
| `versioned_docs/version-1.0.0/hello.md` | 1.0.0          | /docs/1.0.0/hello |
| `versioned_docs/version-1.1.0/hello.md` | 1.1.0 (latest) | /docs/hello       |
| `docs/hello.md`                         | current        | /docs/next/hello  |

:::tip

`docs` 目錄中的文件屬於 `current` 文檔版本。

默認情況下，`current` 文檔版本標記為 `Next` 並托管在 `/docs/next/*` 下，但完全可以根據項目的發布週期進行配置。

:::

### 術語 {#terminology}

請注意此處使用的術語。

<dl>
  <dt>
    <b>Current version</b>
  </dt>
  <dd>
    {'The version placed in the '}
    <code>./docs</code>
    {' folder.'}
  </dd>
  <dt>
    <b>Latest version / last version</b>
  </dt>
  <dd>
    {'The version served by default for docs navbar items. Usually has path '}
    <code>/docs</code>
    {'.'}
  </dd>
</dl>

當前版本由**文件系統位置**定義，而最新版本由**導航行為**定義。它們可能是也可能不是同一個版本！（如上表所示的默認配置會將它們視為不同：當前版本在 `/docs/next`，最新版本在 `/docs`。）

## 教程 {#tutorials}

### 標記新版本 {#tagging-a-new-version}

1. 首先，確保當前文檔版本（`./docs` 目錄）已準備好被凍結。
2. 輸入新的版本號。

```bash npm2yarn
npm run docusaurus docs:version 1.1.0
```

標記新版本時，文檔版本控制機制將：

- 將完整的 `docs/` 文件夾內容複製到新的 `versioned_docs/version-[versionName]/` 文件夾中。
- 根據當前[側邊欄](./sidebar/index.mdx)配置（如果存在）創建版本化側邊欄文件——保存為 `versioned_sidebars/version-[versionName]-sidebars.json`。
- 將新版本號追加到 `versions.json` 中。

### 創建新文檔 {#creating-new-docs}

1. 將新文件放入對應的版本文件夾中。
2. 根據版本號在對應的側邊欄文件中包含對新文件的引用。

```mdx-code-block
<Tabs>
<TabItem value="Current version structure">
```

```bash
# The new file.
docs/new.md

# Edit the corresponding sidebar file.
sidebars.js
```

```mdx-code-block
</TabItem>
<TabItem value="Older version structure">
```

```bash
# The new file.
versioned_docs/version-1.0.0/new.md

# Edit the corresponding sidebar file.
versioned_sidebars/version-1.0.0-sidebars.json
```

```mdx-code-block
</TabItem>
</Tabs>
```

### 更新現有版本 {#updating-an-existing-version}

您可以同時更新多個文檔版本，因為 `versioned_docs/` 中的每個目錄在發布時都代表特定的路由。

1. 編輯任何文件。
2. 提交並推送更改。
3. 它將被發布到該版本。

示例：當您更改 `versioned_docs/version-2.6/` 中的任何文件時，只會影響版本 `2.6` 的文檔。

### 刪除現有版本 {#deleting-an-existing-version}

你也可以刪除/移除版本。

1. 從 `versions.json` 中移除該版本。

範例：

```diff
[
  "2.0.0",
  "1.9.0",
  // highlight-next-line
- "1.8.0"
]
```

2. 刪除版本化文件目錄。範例：`versioned_docs/version-1.8.0`。
3. 刪除版本化側邊欄文件。範例：`versioned_sidebars/version-1.8.0-sidebars.json`。

## 配置版本化行為 {#configuring-versioning-behavior}

「當前」版本是指 `./docs` 文件夾的版本名稱。版本化管理有多種方式，但兩種常見的模式是：

- 你發布了 v1，並立即開始開發 v2（包括其文檔）。在這種情況下，**當前版本**是 v2，位於 `./docs` 源文件夾中，用戶可以在 `example.com/docs/next` 瀏覽。**最新版本**是 v1，位於 `./versioned_docs/version-1` 源文件夾中，大多數用戶會在 `example.com/docs` 瀏覽。
- 你發布了 v1，並會維護一段時間才會考慮 v2。在這種情況下，**當前版本**和**最新版本**都會指向 v1，因為 v2 文檔甚至還不存在！

Docusaurus 的默認設置非常適合第一種使用場景。我們會將當前版本標記為「next」，你甚至可以選擇不發布它。

**對於第二種使用場景**：如果你發布了 v1 並且不打算很快開發 v2，與其將 v1 版本化並需要維護兩個文件夾（`./docs` + `./versioned_docs/version-1.0.0`）中的文檔，你可以考慮「假裝」當前版本是一個已切割的版本，通過為它指定路徑和標籤：

```js title="docusaurus.config.js"
export default {
  presets: [
    '@docusaurus/preset-classic',
    docs: {
      // highlight-start
      lastVersion: 'current',
      versions: {
        current: {
          label: '1.0.0',
          path: '1.0.0',
        },
      },
      // highlight-end
    },
  ],
};
```

`./docs` 中的文檔將在 `/docs/1.0.0` 而非 `/docs/next` 提供，`1.0.0` 將成為我們在導航欄下拉菜單中連結的默認版本，而你只需要維護單一的 `./docs` 文件夾。

我們提供以下插件選項來自定義版本化行為：

- `disableVersioning`：即使有版本也明確禁用版本化。這將使網站僅包含當前版本。
- `includeCurrentVersion`：包含當前版本（`./docs` 文件夾）的文檔。
  - **提示**：如果當前版本是進行中的工作，尚未準備好發布，可以關閉此選項。
- `lastVersion`：設置「最新版本」（`/docs` 路由）指向哪個版本。
  - **提示**：`lastVersion: 'current'` 適用於當前版本指向一個不斷修補和發布的主要版本。最新版本的實際路由基礎路徑和標籤是可配置的。
- `onlyIncludeVersions`：定義從 `versions.json` 中部署的版本子集。
  - **提示**：在開發和部署預覽中限制為 2 或 3 個版本，以提高啟動和構建時間。
- `versions`：版本元數據的字典。對於每個版本，你可以自定義以下內容：
  - `label`：在版本下拉菜單和橫幅中顯示的標籤。
  - `path`：該版本的路由基礎路徑。默認情況下，最新版本為 `/`，當前版本為 `/next`。
  - `banner`：可以是 `'none'`、`'unreleased'` 或 `'unmaintained'`。決定在每個文檔頁面頂部顯示的內容。任何高於最新版本的版本將標記為「unreleased」，低於的則標記為「unmaintained」。
  - `badge`：在該版本文檔的頂部顯示帶有版本名稱的徽章。
  - `className`：為該版本文檔頁面的 `<html>` 元素添加自定義 `className`。

詳見[文檔插件配置](../../api/plugins/plugin-content-docs.mdx#configuration)。

## 導航欄項目 {#navbar-items}

我們提供多種導航欄項目，幫助你快速設置導航，無需擔心版本化路由。

- [`doc`](../../api/themes/theme-configuration.mdx#navbar-doc-link): a link to a doc.
- [`docSidebar`](../../api/themes/theme-configuration.mdx#navbar-doc-sidebar): a link to the first item in a sidebar.
- [`docsVersion`](../../api/themes/theme-configuration.mdx#navbar-docs-version): a link to the main doc of the currently viewed version.
- [`docsVersionDropdown`](../../api/themes/theme-configuration.mdx#navbar-docs-version-dropdown): a dropdown containing all the versions available.

These links would all look for an appropriate version to link to, in the following order:

1. **Active version**: the version that the user is currently browsing, if she is on a page provided by this doc plugin. If she's not on a doc page, fall back to...
2. **Preferred version**: the version that the user last viewed. If there's no history, fall back to...
3. **Latest version**: the default version that we navigate to, configured by the `lastVersion` option.

## Recommended practices {#recommended-practices}

### Version your documentation only when needed {#version-your-documentation-only-when-needed}

For example, you are building documentation for your npm package `foo` and you are currently in version 1.0.0. You then release a patch version for a minor bug fix and it's now 1.0.1.

Should you cut a new documentation version 1.0.1? **You probably shouldn't**. 1.0.1 and 1.0.0 docs shouldn't differ according to semver because there are no new features!. Cutting a new version for it will only just create unnecessary duplicated files.

### Keep the number of versions small {#keep-the-number-of-versions-small}

As a good rule of thumb, try to keep the number of your versions below 10. You will **very likely** to have a lot of obsolete versioned documentation that nobody even reads anymore. For example, [Jest](https://jestjs.io/versions) is currently in version `27.4`, and only maintains several latest documentation versions with the lowest being `25.X`. Keep it small 😊

:::tip[archive older versions]

If you deploy your site on a Jamstack provider (e.g. [Netlify](../../deployment.mdx)), the provider will save each production build as a snapshot under an immutable URL. You can include archived versions that will never be rebuilt as external links to these immutable URLs. The Jest website and the Docusaurus website both use such pattern to keep the number of actively built versions low.

:::

### Use absolute import within the docs {#use-absolute-import-within-the-docs}

Don't use relative paths import within the docs. Because when we cut a version the paths no longer work (the nesting level is different, among other reasons). You can utilize the `@site` alias provided by Docusaurus that points to the `website` directory. Example:

```diff
- import Foo from '../src/components/Foo';
+ import Foo from '@site/src/components/Foo';
```

### Link docs by file paths {#link-docs-by-file-paths}

Refer to other docs by relative file paths with the `.md` extension, so that Docusaurus can rewrite them to actual URL paths during building. Files will be linked to the correct corresponding version.

```md
The [@hello](hello.mdx#paginate) document is great!

See the [Tutorial](../getting-started/tutorial.mdx) for more info.
```

### Global or versioned collocated assets {#global-or-versioned-collocated-assets}

You should decide if assets like images and files are per-version or shared between versions.

If your assets should be versioned, put them in the docs version, and use relative paths:

```md
![img alt](./myImage.png)

[download this file](./file.pdf)
```

If your assets are global, put them in `/static` and use absolute paths:

```md
![img alt](/myImage.png)

[download this file](/file.pdf)
```