---
description: Customize your site's appearance through creating your own theme components
---

# 元件替換(Swizzling)

本章節將介紹如何在 Docusaurus 中自訂版面配置。

> 似曾相識...？

本節與[樣式與版面](./styling-layout.mdx)類似，但這次我們將自訂 React 元件本身，而非其外觀。我們將探討 Docusaurus 的核心概念：**元件替換(Swizzling)**，這項技術允許進行**更深層的網站客製化**。

實務上，元件替換可透過兩種模式**替換主題元件為自行實作的版本**：

- [**抽離(Ejecting)**](#ejecting)：建立原始主題元件的**副本**，可進行完整**客製化**
- [**包裝(Wrapping)**](#wrapping)：建立原始主題元件的**包裝器**，可進行**功能增強**

<details>

<summary>Why is it called swizzling?</summary>

**The name comes from Objective-C and Swift-UI**: [method swizzling](https://pspdfkit.com/blog/2019/swizzling-in-swift/) is the process of changing the implementation of an existing selector (method).

**For Docusaurus, component swizzling means providing an alternative component that takes precedence over the component provided by the theme.**

You can think of it as [Monkey Patching](https://en.wikipedia.org/wiki/Monkey_patch) for React components, enabling you to override the default implementation. Gatsby has a similar concept called [theme shadowing](https://www.gatsbyjs.com/docs/how-to/plugins-and-themes/shadowing/).

To gain a deeper understanding of this, you have to understand [how theme components are resolved](./advanced/client.mdx#theme-aliases).

</details>

## 元件替換流程

### 概述

Docusaurus 提供便利的**互動式 CLI** 來替換元件，通常只需記住以下指令：

```bash npm2yarn
npm run swizzle
```

該指令會在您的 `src/theme` 目錄中生成新元件，範例如下：

```mdx-code-block
<Tabs>
<TabItem value="Ejecting">
```

```jsx title="src/theme/SomeComponent.js"
import React from 'react';

export default function SomeComponent(props) {
  // You can fully customize this implementation
  // including changing the JSX, CSS and React hooks
  return (
    <div className="some-class">
      <h1>Some Component</h1>
      <p>Some component implementation details</p>
    </div>
  );
}
```

```mdx-code-block
</TabItem>
<TabItem value="Wrapping">
```

```jsx title="src/theme/SomeComponent.js"
import React from 'react';
import SomeComponent from '@theme-original/SomeComponent';

export default function SomeComponentWrapper(props) {
  // You can enhance the original component,
  // including adding extra props or JSX elements around it
  return (
    <>
      <SomeComponent {...props} />
    </>
  );
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

若要查看所有可替換的主題與元件概覽，請執行：

```bash npm2yarn
npm run swizzle -- --list
```

使用 `--help` 參數查看所有可用 CLI 選項，或參考[元件替換 CLI 文件](./cli.mdx#docusaurus-swizzle)。

:::tip[移除不再需要的替換元件]

若決定不再需要先前替換的元件，只需從 `src/theme` 目錄刪除其檔案。移除元件後，請重新啟動開發伺服器以確保變更生效。

:::

:::note

替換元件後，**請重啟開發伺服器**讓 Docusaurus 識別新元件。

:::

:::warning[建議優先選擇安全方案]

請務必了解[哪些元件可安全替換](#what-is-safe-to-swizzle)。部分元件是主題的**內部實作細節**。

:::

:::info

`docusaurus swizzle` 僅是協助自動化替換元件的工具。您也可以手動建立 `src/theme/SomeComponent.js` 檔案，Docusaurus 會[自動解析](./advanced/client.mdx#theme-aliases)。此命令背後並無特殊魔法！

:::

### 抽離(Ejecting) {#ejecting}

抽離主題元件是指**建立原始主題元件的副本**，您可對其進行**完整客製化與覆寫**。

要抽離主題元件，請使用互動式元件替換 CLI 或搭配 `--eject` 參數：

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --eject
```

範例：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --eject
```

此操作會將當前 `<Footer />` 元件的實作複製到您網站的 `src/theme` 目錄。Docusaurus 將使用此 `<Footer>` 元件副本而非原始版本。您現在可以完全重新實作 `<Footer>` 元件。

```jsx title="src/theme/Footer/index.js"
import React from 'react';

export default function Footer(props) {
  return (
    <footer>
      <h1>This is my custom site footer</h1>
      <p>And it is very different from the original</p>
    </footer>
  );
}
```

:::warning

[**不安全**](#what-is-safe-to-swizzle)元件的彈出(eject)有時會導致複製大量內部代碼，這些代碼現在需要由您自行維護。這可能使Docusaurus升級更加困難，因為如果接收的props或使用的內部主題API發生變化，您需要遷移自定義內容。

**盡可能優先選擇[包裝(wrapping)](#wrapping)**：需要維護的代碼量較少。

:::

:::tip[重新混寫(Re-swizzling)]

為了在Docusaurus升級後保持彈出元件的最新狀態，請重新運行彈出命令並使用`git diff`比較變更。建議在文件頂部添加簡短註解說明您所做的修改，以便在重新彈出後能更輕鬆地重新應用這些變更。

:::

### 包裝(Wrapping) {#wrapping}

包裝主題元件是指**創建一個包裝器**環繞原始主題元件，您可以對其進行**增強**。

要包裝主題元件，請使用交互式混寫CLI，或加上`--wrap`選項：

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --wrap
```

範例：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --wrap
```

這將在您的網站`src/theme`目錄中創建一個包裝器。Docusaurus現在將使用`<FooterWrapper>`元件替代原始元件。您現在可以在原始元件周圍添加自定義內容。

```jsx title="src/theme/Footer/index.js"
import React from 'react';
import Footer from '@theme-original/Footer';

export default function FooterWrapper(props) {
  return (
    <>
      <section>
        <h2>Extra section</h2>
        <p>This is an extra section that appears above the original footer</p>
      </section>
      <Footer {...props} />
    </>
  );
}
```

<details>
  <summary>What is this <code>@theme-original</code> thing?</summary>

Docusaurus uses [theme aliases](./advanced/client.mdx#theme-aliases) to resolve the theme components to use. The newly created wrapper takes the `@theme/SomeComponent` alias. `@theme-original/SomeComponent` permits to import original component that the wrapper shadows without creating an infinite import loop where the wrapper imports itself.

</details>

:::tip

包裝主題是**在現有元件周圍添加額外元件**而不需[彈出(ejecting)](#ejecting)的絕佳方式。例如，您可以輕鬆在每篇博客文章下方添加自定義評論系統：

```jsx title="src/theme/BlogPostItem.js"
import React from 'react';
import BlogPostItem from '@theme-original/BlogPostItem';
import MyCustomCommentSystem from '@site/src/MyCustomCommentSystem';

export default function BlogPostItemWrapper(props) {
  return (
    <>
      <BlogPostItem {...props} />
      <MyCustomCommentSystem />
    </>
  );
}
```

:::

## 哪些元件可以安全混寫？ {#what-is-safe-to-swizzle}

> 能力越大，責任越大

某些主題元件是主題的**內部實現細節**。Docusaurus允許您混寫它們，但**可能存在風險**。

<details>

<summary>Why is it risky?</summary>

Theme authors (including us) might have to update their theme over time: changing the component props, name, file system location, types... For example, consider a component that receives two props `name` and `age`, but after a refactor, it now receives a `person` prop with the above two properties. Your component, which still expects these two props, will render `undefined` instead.

Moreover, internal components may simply disappear. If a component is called `Sidebar` and it's later renamed to `DocSidebar`, your swizzled component will be completely ignored.

**Theme components marked as unsafe may change in a backward-incompatible way between theme minor versions.** When upgrading a theme (or Docusaurus), your customizations might **behave unexpectedly**, and can even **break your site**.

</details>

對於每個主題元件，混寫CLI會標示主題作者聲明的**3種不同安全等級**：

- **安全(Safe)**：此元件可安全混寫，其公共API被視為穩定，在主題**主要版本**內不應發生破壞性變更
- **不安全(Unsafe)**：此元件是主題實現細節，混寫不安全，可能在主題**次要版本**升級時發生破壞性變更
- **禁止(Forbidden)**：混寫CLI將阻止您混寫此元件，因為它從設計上就不應被混寫

:::note

某些元件可能適合包裝(wrap)，但不適合彈出(eject)。

:::

:::info

不必過度**害怕混寫不安全元件**：只需記住可能會發生**破壞性變更**，您可能需要在次要版本升級時手動更新自定義內容。

:::

:::note[報告使用案例]

如果您有**強烈需求必須混寫不安全元件**，請[**在此報告**](https://github.com/facebook/docusaurus/discussions/5468)，我們將共同尋找解決方案使其變得安全。

:::

## 應該混寫哪個元件？ {#which-component-should-i-swizzle}

要實現預期效果，通常並不明確應該具體混寫哪個元件。提供大多數主題元件的`@docusaurus/theme-classic`包含約[100個元件](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)！

:::tip

要列印所有 `@docusaurus/theme-classic` 元件的概覽：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic -- --list
```

:::

您可以按照以下步驟來定位需要替換的適當元件：

1. **元件描述**。部分元件提供簡短說明，這是找到正確元件的好方法。
2. **元件名稱**。官方主題元件採用語義化命名，因此您應能從名稱推斷其功能。替換 CLI 允許您輸入部分元件名稱來縮小可用選項範圍。例如，若執行 `yarn swizzle @docusaurus/theme-classic` 並輸入 `Doc`，則僅會列出與文檔相關的元件。
3. **從高階元件開始**。元件會形成樹狀結構，部分元件會導入其他元件。每條路由都會關聯一個頂層元件（大多數列於[內容外掛路由](./advanced/routing.mdx#routing-in-content-plugins)中），該元件將由路由渲染。例如，所有部落格文章頁面的最頂層元件都是 `@theme/BlogPostPage`。您可以先替換此元件，然後沿元件樹向下定位到僅渲染您目標內容的元件。找到正確元件後，請記得刪除其餘元件檔案以取消替換，避免維護過多元件。
4. **閱讀[主題原始碼](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)**並善用搜尋功能。

:::tip[直接詢問！]

若仍不確定該替換哪個元件以達成預期效果，可透過我們的[支援管道](/community/support)尋求協助。

我們也希望更了解您最精緻的客製化使用案例，請[**提交報告**](https://github.com/facebook/docusaurus/discussions/5468)。

:::

## 是否需要替換元件？ {#do-i-need-to-swizzle}

替換元件最終意味著您需維護一些與 Docusaurus 內部 API 互動的 React 程式碼。若有可能，在客製化網站時請考慮以下替代方案：

1. **使用 CSS**。CSS 規則和選擇器通常能協助達成相當程度的客製化。詳見[樣式與版面配置](./styling-layout.mdx)。
2. **使用翻譯**。聽起來可能令人驚訝，但翻譯本質上只是自訂文字標籤的一種方式。例如，若您的網站預設語言為 `en`，仍可執行 `yarn write-translations -l en` 並編輯產生的 `code.json` 檔案。詳見[i18n 教學](./i18n/i18n-tutorial.mdx)。

:::tip

**越小越好**。若必須替換元件，請優先僅替換相關部分，並盡量減少自行維護的程式碼量。替換小型元件通常意味著升級時**破壞性變更**的風險較低。

[封裝](#wrapping)也是比[彈出](#ejecting)更安全的替代方案。

:::

## 使用 `<Root>` 封裝您的網站 {#wrapper-your-site-with-root}

`<Root>` 元件會渲染在 React 樹的**最頂層**，位於主題 `<Layout>` 之上，且**永不卸載**。它是添加不應在導航間重新初始化之狀態邏輯（使用者驗證狀態、購物車狀態等）的理想位置。

手動替換此元件，請在 `src/theme/Root.js` 建立檔案：

```js title="src/theme/Root.js"
import React from 'react';

// Default implementation, that you can customize
export default function Root({children}) {
  return <>{children}</>;
}
```

:::tip

使用此元件來渲染 React Context 提供者。

:::