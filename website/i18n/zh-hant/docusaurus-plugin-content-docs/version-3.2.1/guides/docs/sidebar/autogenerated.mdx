---
slug: /sidebar/autogenerated
---

# 自動生成

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

Docusaurus 能根據**檔案系統結構**自動建立側邊欄：每個資料夾生成一個分類目錄，每個檔案生成一個文件連結。

```ts
type SidebarItemAutogenerated = {
  type: 'autogenerated';
  dirName: string; // Source folder to generate the sidebar slice from (relative to docs)
};
```

Docusaurus 可從您的文件資料夾生成完整側邊欄：

```js title="sidebars.js"
export default {
  myAutogeneratedSidebar: [
    // highlight-start
    {
      type: 'autogenerated',
      dirName: '.', // '.' means the current docs folder
    },
    // highlight-end
  ],
};
```

`autogenerated` 項目會被 Docusaurus 轉換為**側邊欄片段**（詳見[分類速記](items.mdx#category-shorthand)）：由 `doc` 或 `category` 類型項目組成的列表，因此您可以在單一側邊欄層級中，將**多個 `autogenerated` 項目**從不同目錄拼接，並與常規側邊欄項目交錯排列。

<details>
<summary>A real-world example</summary>

Consider this file structure:

```bash
docs
├── api
│   ├── product1-api
│   │   └── api.md
│   └── product2-api
│       ├── basic-api.md
│       └── pro-api.md
├── intro.md
└── tutorials
    ├── advanced
    │   ├── advanced1.md
    │   ├── advanced2.md
    │   └── read-more
    │       ├── resource1.md
    │       └── resource2.md
    ├── easy
    │   ├── easy1.md
    │   └── easy2.md
    ├── tutorial-end.md
    ├── tutorial-intro.md
    └── tutorial-medium.md
```

And assume every doc's ID is just its file name. If you define an autogenerated sidebar like this:

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: 'Tutorials',
      items: [
        'tutorial-intro',
        // highlight-start
        {
          type: 'autogenerated',
          dirName: 'tutorials/easy', // Generate sidebar slice from docs/tutorials/easy
        },
        // highlight-end
        'tutorial-medium',
        // highlight-start
        {
          type: 'autogenerated',
          dirName: 'tutorials/advanced', // Generate sidebar slice from docs/tutorials/advanced
        },
        // highlight-end
        'tutorial-end',
      ],
    },
    // highlight-start
    {
      type: 'autogenerated',
      dirName: 'api', // Generate sidebar slice from docs/api
    },
    // highlight-end
    {
      type: 'category',
      label: 'Community',
      items: ['team', 'chat'],
    },
  ],
};
```

It would be resolved as:

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: 'Tutorials',
      items: [
        'tutorial-intro',
        // highlight-start
        // Two files in docs/tutorials/easy
        'easy1',
        'easy2',
        // highlight-end
        'tutorial-medium',
        // highlight-start
        // Two files and a folder in docs/tutorials/advanced
        'advanced1',
        'advanced2',
        {
          type: 'category',
          label: 'read-more',
          items: ['resource1', 'resource2'],
        },
        // highlight-end
        'tutorial-end',
      ],
    },
    // highlight-start
    // Two folders in docs/api
    {
      type: 'category',
      label: 'product1-api',
      items: ['api'],
    },
    {
      type: 'category',
      label: 'product2-api',
      items: ['basic-api', 'pro-api'],
    },
    // highlight-end
    {
      type: 'category',
      label: 'Community',
      items: ['team', 'chat'],
    },
  ],
};
```

Note how the autogenerate source directories themselves don't become categories: only the items they contain do. This is what we mean by "sidebar slice".

</details>

## 分類索引慣例 {#category-index-convention}

Docusaurus 能自動將分類連結至其索引文件。

分類索引文件需符合以下文件名慣例之一：

- 命名為 `index`（不分大小寫）：`docs/Guides/index.md`
- 命名為 `README`（不分大小寫）：`docs/Guides/README.mdx`
- 與父資料夾同名：`docs/Guides/Guides.md`

這等同於使用帶有[文件連結](items.mdx#category-doc-link)的分類：

```js title="sidebars.js"
export default {
  docs: [
    // highlight-start
    {
      type: 'category',
      label: 'Guides',
      link: {type: 'doc', id: 'Guides/index'},
      items: [],
    },
    // highlight-end
  ],
};
```

:::tip

將入門文件命名為 `README.md` 可讓其在 GitHub 介面瀏覽資料夾時顯示，而使用 `index.md` 則更符合 HTML 文件的服務行為。

:::

:::tip

若資料夾僅包含一個索引頁面，它將被轉換為連結而非分類。這對**資源共置**特別有用：

```
some-doc
├── index.md
├── img1.png
└── img2.png
```

:::

<details>

<summary>Customizing category index matching</summary>

It is possible to opt out any of the category index conventions, or define even more conventions. You can inject your own `isCategoryIndex` matcher through the [`sidebarItemsGenerator`](#customize-the-sidebar-items-generator) callback. For example, you can also pick `intro` as another file name eligible for automatically becoming the category index.

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // The default matcher implementation, given below
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // highlight-start
            isCategoryIndex(doc) {
              return (
                // Also pick intro.md in addition to the default ones
                doc.fileName.toLowerCase() === 'intro' ||
                defaultCategoryIndexMatcher(doc)
              );
            },
            // highlight-end
          });
        },
      },
    ],
  ],
};
```

Or choose to not have any category index convention.

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // The default matcher implementation, given below
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // highlight-start
            isCategoryIndex() {
              // No doc will be automatically picked as category index
              return false;
            },
            // highlight-end
          });
        },
      },
    ],
  ],
};
```

The `isCategoryIndex` matcher will be provided with three fields:

- `fileName`, the file's name without extension and with casing preserved
- `directories`, the list of directory names _from the lowest level to the highest level_, relative to the docs root directory
- `extension`, the file's extension, with a leading dot.

For example, for a doc file at `guides/sidebar/autogenerated.md`, the props the matcher receives are

```js
const props = {
  fileName: 'autogenerated',
  directories: ['sidebar', 'guides'],
  extension: '.md',
};
```

The default implementation is:

```js
function isCategoryIndex({fileName, directories}) {
  const eligibleDocIndexNames = [
    'index',
    'readme',
    directories[0].toLowerCase(),
  ];
  return eligibleDocIndexNames.includes(fileName.toLowerCase());
}
```

</details>

## 自動生成側邊欄中繼資料 {#autogenerated-sidebar-metadata}

手寫側邊欄定義時，您會透過 `sidebars.js` 提供中繼資料；自動生成時，Docusaurus 會從項目對應檔案讀取。此外，您可能需要調整各項目的相對位置，因為預設情況下，側邊欄片段中的項目會按**字母順序**（使用檔案和資料夾名稱）生成。

### 文件項目中繼資料 {#doc-item-metadata}

`label`、`className` 和 `customProps` 屬性分別在 front matter 中宣告為 `sidebar_label`、`sidebar_class_name` 和 `sidebar_custom_props`。位置可透過 `sidebar_position` front matter 以相同方式指定。

```md title="docs/tutorials/tutorial-easy.md"
---
# highlight-start
sidebar_position: 2
sidebar_label: Easy
sidebar_class_name: green
# highlight-end
---

# Easy Tutorial

This is the easy tutorial!
```

### 分類項目中繼資料 {#category-item-metadata}

在相應資料夾中添加 `_category_.json` 或 `_category_.yml` 檔案。您可指定任何分類中繼資料及 `position` 中繼資料。若存在分類的連結文件，`label`、`className`、`position` 和 `customProps` 將預設採用該文件的對應值。

<Tabs>
<TabItem value="JSON">

```json title="docs/tutorials/_category_.json"
{
  "position": 2.5,
  "label": "Tutorial",
  "collapsible": true,
  "collapsed": false,
  "className": "red",
  "link": {
    "type": "generated-index",
    "title": "Tutorial overview"
  },
  "customProps": {
    "description": "This description can be used in the swizzled DocCard"
  }
}
```

</TabItem>
<TabItem value="YAML">

```yml title="docs/tutorials/_category_.yml"
position: 2.5 # float position is supported
label: 'Tutorial'
collapsible: true # make the category collapsible
collapsed: false # keep the category open by default
className: red
link:
  type: generated-index
  title: Tutorial overview
customProps:
  description: This description can be used in the swizzled DocCard
```

</TabItem>
</Tabs>

:::info

若明確指定 `link`，Docusaurus 將不套用任何[預設慣例](#category-index-convention)。

文件連結可相對指定，例如當分類由 `guides` 目錄生成時，`"link": {"type": "doc", "id": "intro"}` 將解析為 ID `guides/intro`，僅在前者 ID 不存在時回退至 `intro`。

您也可使用 `link: null` 選擇退出預設慣例，且不生成任何分類索引頁面。

:::

:::info

位置中繼資料僅在**側邊欄片段內**生效：Docusaurus 不會重新排序側邊欄的其他項目。

:::

## Using number prefixes {#using-number-prefixes}

A simple way to order an autogenerated sidebar is to prefix docs and folders by number prefixes, which also makes them appear in the file system in the same order when sorted by file name:

```bash
docs
├── 01-Intro.md
├── 02-Tutorial Easy
│   ├── 01-First Part.md
│   ├── 02-Second Part.md
│   └── 03-End.md
├── 03-Tutorial Advanced
│   ├── 01-First Part.md
│   ├── 02-Second Part.md
│   ├── 03-Third Part.md
│   └── 04-End.md
└── 04-End.md
```

To make it **easier to adopt**, Docusaurus supports **multiple number prefix patterns**.

By default, Docusaurus will **remove the number prefix** from the doc id, title, label, and URL paths.

:::warning

**Prefer using [additional metadata](#autogenerated-sidebar-metadata)**.

Updating a number prefix can be annoying, as it can require **updating multiple existing Markdown links**:

```diff title="docs/02-Tutorial Easy/01-First Part.md"
- Check the [Tutorial End](../04-End.mdx);
+ Check the [Tutorial End](../05-End.mdx);
```

:::

## Customize the sidebar items generator {#customize-the-sidebar-items-generator}

You can provide a custom `sidebarItemsGenerator` function in the docs plugin (or preset) config:

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // highlight-start
        async sidebarItemsGenerator({
          defaultSidebarItemsGenerator,
          numberPrefixParser,
          item,
          version,
          docs,
          categoriesMetadata,
          isCategoryIndex,
        }) {
          // Example: return an hardcoded list of static sidebar items
          return [
            {type: 'doc', id: 'doc1'},
            {type: 'doc', id: 'doc2'},
          ];
        },
        // highlight-end
      },
    ],
  ],
};
```

:::tip

**Re-use and enhance the default generator** instead of writing a generator from scratch: [the default generator we provide](https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-plugin-content-docs/src/sidebars/generator.ts) is 250 lines long.

**Add, update, filter, re-order** the sidebar items according to your use case:

```js title="docusaurus.config.js"
// highlight-start
// Reverse the sidebar items ordering (including nested category items)
function reverseSidebarItems(items) {
  // Reverse items in categories
  const result = items.map((item) => {
    if (item.type === 'category') {
      return {...item, items: reverseSidebarItems(item.items)};
    }
    return item;
  });
  // Reverse items at current level
  result.reverse();
  return result;
}
// highlight-end

export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // highlight-start
        async sidebarItemsGenerator({defaultSidebarItemsGenerator, ...args}) {
          const sidebarItems = await defaultSidebarItemsGenerator(args);
          return reverseSidebarItems(sidebarItems);
        },
        // highlight-end
      },
    ],
  ],
};
```

:::