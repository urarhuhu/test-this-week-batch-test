---
description: Customize your site's appearance through creating your own theme components
---

# 元件替換 (Swizzling)

本章節將介紹如何在 Docusaurus 中進行佈局客製化。

> 似曾相識...？

本節與[樣式與佈局](./styling-layout.mdx)類似，但這次我們將客製化 React 元件本身，而非其外觀樣式。我們將討論 Docusaurus 的核心概念：**元件替換 (swizzling)**，這項技術允許進行**更深層的網站客製化**。

實務上，元件替換允許您**用自訂實作替換主題元件**，主要分為兩種模式：

- [**完整替換 (Ejecting)**](#ejecting)：建立原始主題元件的**副本**，可進行完整**客製化**
- [**封裝替換 (Wrapping)**](#wrapping)：建立原始主題元件的**封裝層**，可進行**功能增強**

<details>

<summary>Why is it called swizzling?</summary>

**The name comes from Objective-C and Swift-UI**: [method swizzling](https://pspdfkit.com/blog/2019/swizzling-in-swift/) is the process of changing the implementation of an existing selector (method).

**For Docusaurus, component swizzling means providing an alternative component that takes precedence over the component provided by the theme.**

You can think of it as [Monkey Patching](https://en.wikipedia.org/wiki/Monkey_patch) for React components, enabling you to override the default implementation. Gatsby has a similar concept called [theme shadowing](https://www.gatsbyjs.com/docs/how-to/plugins-and-themes/shadowing/).

To gain a deeper understanding of this, you have to understand [how theme components are resolved](./advanced/client.mdx#theme-aliases).

</details>

## 元件替換流程

### 概述

Docusaurus 提供便利的**互動式 CLI** 來替換元件，通常只需記住以下指令：

```bash npm2yarn
npm run swizzle
```

執行後會在您的 `src/theme` 目錄生成新元件，範例如下：

```mdx-code-block
<Tabs>
<TabItem value="Ejecting">
```

```jsx title="src/theme/SomeComponent.js"
import React from 'react';

export default function SomeComponent(props) {
  // You can fully customize this implementation
  // including changing the JSX, CSS and React hooks
  return (
    <div className="some-class">
      <h1>Some Component</h1>
      <p>Some component implementation details</p>
    </div>
  );
}
```

```mdx-code-block
</TabItem>
<TabItem value="Wrapping">
```

```jsx title="src/theme/SomeComponent.js"
import React from 'react';
import SomeComponent from '@theme-original/SomeComponent';

export default function SomeComponentWrapper(props) {
  // You can enhance the original component,
  // including adding extra props or JSX elements around it
  return (
    <>
      <SomeComponent {...props} />
    </>
  );
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

若要查看所有可替換的主題與元件清單，請執行：

```bash npm2yarn
npm run swizzle -- --list
```

使用 `--help` 參數查看所有可用 CLI 選項，或參考[元件替換 CLI 文件](./cli.mdx#docusaurus-swizzle)。

:::note

替換元件後，請**重新啟動開發伺服器**，讓 Docusaurus 識別新元件。

:::

:::warning[建議保持安全替換]

請務必了解[哪些元件屬於**安全替換範圍**](#what-is-safe-to-swizzle)。部分元件是主題的**內部實作細節**。

:::

:::info

`docusaurus swizzle` 僅是協助自動化替換元件的工具。您也可以手動建立 `src/theme/SomeComponent.js` 文件，Docusaurus 會[自動解析](./advanced/client.mdx#theme-aliases)。此命令背後並無特殊魔法！

:::

### 完整替換 {#ejecting}

完整替換主題元件是指**建立原始元件的副本**，您可對其進行**完全客製化與覆寫**。

要完整替換主題元件，請使用互動式 swizzle CLI 或搭配 `--eject` 參數：

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --eject
```

範例：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --eject
```

此操作會將當前 `<Footer />` 元件的實作複製到您網站的 `src/theme` 目錄。Docusaurus 將使用此副本而非原始元件。您現在可以完全重新實作 `<Footer>` 元件。

```jsx title="src/theme/Footer/index.js"
import React from 'react';

export default function Footer(props) {
  return (
    <footer>
      <h1>This is my custom site footer</h1>
      <p>And it is very different from the original</p>
    </footer>
  );
}
```

:::warning

完整替換[**非安全**](#what-is-safe-to-swizzle)元件可能導致複製大量內部代碼，後續需自行維護。這會增加 Docusaurus 升級難度，若接收的 props 或使用的內部主題 API 發生變更，您需自行遷移客製化內容。

**建議盡可能採用[封裝替換](#wrapping)**：需維護的代碼量較少。

:::

:::tip[Re-swizzling]

To keep ejected components up-to-date after a Docusaurus upgrade, re-run the eject command and compare the changes with `git diff`. You are also recommended to write a brief comment at the top of the file explaining what changes you have made, so that you could more easily re-apply your changes after re-ejection.

:::

### Wrapping {#wrapping}

Wrapping a theme component is the process of **creating a wrapper** around the original theme component, which you can **enhance**.

To wrap a theme component, use the swizzle CLI interactively, or with the `--wrap` option:

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --wrap
```

An example:

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --wrap
```

This will create a wrapper in your site's `src/theme` directory. Docusaurus will now use the `<FooterWrapper>` component instead of the original one. You can now add customizations around the original component.

```jsx title="src/theme/Footer/index.js"
import React from 'react';
import Footer from '@theme-original/Footer';

export default function FooterWrapper(props) {
  return (
    <>
      <section>
        <h2>Extra section</h2>
        <p>This is an extra section that appears above the original footer</p>
      </section>
      <Footer {...props} />
    </>
  );
}
```

<details>
  <summary>What is this <code>@theme-original</code> thing?</summary>

Docusaurus uses [theme aliases](./advanced/client.mdx#theme-aliases) to resolve the theme components to use. The newly created wrapper takes the `@theme/SomeComponent` alias. `@theme-original/SomeComponent` permits to import original component that the wrapper shadows without creating an infinite import loop where the wrapper imports itself.

</details>

:::tip

Wrapping a theme is a great way to **add extra components around existing one** without [ejecting](#ejecting) it. For example, you can easily add a custom comment system under each blog post:

```jsx title="src/theme/BlogPostItem.js"
import React from 'react';
import BlogPostItem from '@theme-original/BlogPostItem';
import MyCustomCommentSystem from '@site/src/MyCustomCommentSystem';

export default function BlogPostItemWrapper(props) {
  return (
    <>
      <BlogPostItem {...props} />
      <MyCustomCommentSystem />
    </>
  );
}
```

:::

## What is safe to swizzle? {#what-is-safe-to-swizzle}

> With great power comes great responsibility

Some theme components are **internal implementation details** of a theme. Docusaurus allows you to swizzle them, but it **might be risky**.

<details>

<summary>Why is it risky?</summary>

Theme authors (including us) might have to update their theme over time: changing the component props, name, file system location, types... For example, consider a component that receives two props `name` and `age`, but after a refactor, it now receives a `person` prop with the above two properties. Your component, which still expects these two props, will render `undefined` instead.

Moreover, internal components may simply disappear. If a component is called `Sidebar` and it's later renamed to `DocSidebar`, your swizzled component will be completely ignored.

**Theme components marked as unsafe may change in a backward-incompatible way between theme minor versions.** When upgrading a theme (or Docusaurus), your customizations might **behave unexpectedly**, and can even **break your site**.

</details>

For each theme component, the swizzle CLI will indicate **3 different levels of safety** declared by theme authors:

- **Safe**: this component is safe to be swizzled, its public API is considered stable, and no breaking changes should happen within a theme **major version**
- **Unsafe**: this component is a theme implementation detail, not safe to be swizzled, and breaking changes might happen within a theme **minor version**
- **Forbidden**: the swizzle CLI will prevent you from swizzling this component, because it is not designed to be swizzled at all

:::note

Some components might be safe to wrap, but not safe to eject.

:::

:::info

Don't be too **afraid to swizzle unsafe components**: just keep in mind that **breaking changes** might happen, and you might need to upgrade your customizations manually on minor version upgrades.

:::

:::note[Report your use-case]

If you have a **strong use-case for swizzling an unsafe component**, please [**report it here**](https://github.com/facebook/docusaurus/discussions/5468) and we will work together to find a solution to make it safe.

:::

## Which component should I swizzle? {#which-component-should-i-swizzle}

It is not always clear which component you should swizzle exactly to achieve the desired result. `@docusaurus/theme-classic`, which provides most of the theme components, has about [100 components](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)!

:::tip

To print an overview of all the `@docusaurus/theme-classic` components:

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic -- --list
```

:::

You can follow these steps to locate the appropriate component to swizzle:

1. **元件描述**。部分元件提供簡短說明，這是快速找到合適元件的有效方式。
2. **元件名稱**。官方主題元件皆採用語義化命名，您可從名稱推斷其功能。Swizzle CLI 允許輸入部分元件名稱來篩選選項。例如執行 `yarn swizzle @docusaurus/theme-classic` 後輸入 `Doc`，將僅列出與文檔相關的元件。
3. **從高階元件開始**。元件形成樹狀結構，部分元件會導入其他元件。每條路由都會關聯一個頂層元件（多數列於[內容外掛路由](./advanced/routing.mdx#routing-in-content-plugins)）。例如所有部落格文章頁面的最頂層元件都是 `@theme/BlogPostPage`。您可以先swizzle此元件，再向下遍歷元件樹定位目標元件。找到正確元件後，請刪除其他swizzle產生的檔案以避免維護過多元件。
4. **閱讀[主題原始碼](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)**並善用搜尋功能。

:::tip[直接提問！]

若仍無法確定該swizzle哪個元件來實現需求，可透過我們的[支援管道](/community/support)尋求協助。

我們也希望更了解您的客製化需求，請[提交案例討論](https://github.com/facebook/docusaurus/discussions/5468)。

:::

## 是否必須swizzle？ {#do-i-need-to-swizzle}

Swizzle意味著您需要維護與Docusaurus內部API互動的React程式碼。在客製化網站時，請優先考慮以下替代方案：

1. **使用CSS**。CSS規則和選擇器通常能實現相當程度的客製化，詳見[樣式與版面](./styling-layout.mdx)。
2. **使用翻譯**。雖然看似不直觀，但翻譯本質上是自訂文字標籤的方式。例如若網站預設語言為`en`，仍可執行`yarn write-translations -l en`後編輯生成的`code.json`，詳見[i18n教學](./i18n/i18n-tutorial.mdx)。

:::tip

**範圍越小越好**。若必須swizzle，請僅針對相關部分進行，並盡量減少自行維護的程式碼量。swizzle小型元件通常能降低升級時的**破壞性變更**風險。

相較於[完整抽離](#ejecting)，[包裝元件](#wrapping)是更安全的替代方案。

:::

## 使用`<Root>`包裝您的網站 {#wrapper-your-site-with-root}

`<Root>`元件會渲染在React樹的最頂層（高於主題`<Layout>`），且**永遠不會卸載**。這是最適合放置跨頁面導航時需保持狀態的邏輯（如使用者認證狀態、購物車狀態等）的位置。

請手動建立`src/theme/Root.js`檔案來swizzle此元件：

```js title="src/theme/Root.js"
import React from 'react';

// Default implementation, that you can customize
export default function Root({children}) {
  return <>{children}</>;
}
```

:::tip

建議在此元件中渲染React Context providers。

:::