---
description: How the Docusaurus client is structured
---

# 客戶端架構

## 主題別名 {#theme-aliases}

主題通過導出一組組件（如 `Navbar`、`Layout`、`Footer`）來渲染從插件傳遞下來的數據。Docusaurus 和使用者通過使用 `@theme` 這個 webpack 別名來導入這些組件：

```js
import Navbar from '@theme/Navbar';
```

別名 `@theme` 可以指向以下幾個目錄，優先級如下：

1. 使用者的 `website/src/theme` 目錄，這是一個具有最高優先級的特殊目錄。
2. Docusaurus 主題包的 `theme` 目錄。
3. Docusaurus 核心提供的備用組件（通常不需要）。

這稱為_分層架構_：高優先級的層提供的組件會遮蔽低優先級的層，從而實現組件替換（swizzling）。假設有以下結構：

```
website
├── node_modules
│   └── @docusaurus/theme-classic
│       └── theme
│           └── Navbar.js
└── src
    └── theme
        └── Navbar.js
```

當導入 `@theme/Navbar` 時，`website/src/theme/Navbar.js` 會優先被使用。這種行為稱為組件替換。如果你熟悉 Objective C，其中函數的實現可以在運行時被替換，這裡的概念完全相同，只是改變了 `@theme/Navbar` 指向的目標！

我們已經討論過 `src/theme` 中的「使用者主題」如何通過 [`@theme-original`](../swizzling.mdx#wrapping) 別名重新使用主題組件。一個主題包也可以通過從初始主題導入組件，使用 `@theme-init` 導入來包裝另一個主題的組件。

以下是一個使用此功能來增強默認主題 `CodeBlock` 組件，添加 `react-live` 遊玩功能的例子。

```js
import InitialCodeBlock from '@theme-init/CodeBlock';
import React from 'react';

export default function CodeBlock(props) {
  return props.live ? (
    <ReactLivePlayground {...props} />
  ) : (
    <InitialCodeBlock {...props} />
  );
}
```

詳情請查看 `@docusaurus/theme-live-codeblock` 的代碼。

:::warning

除非你想發布一個可重用的「主題增強器」（如 `@docusaurus/theme-live-codeblock`），否則你可能不需要使用 `@theme-init`。

:::

這些別名可能讓人難以理解。讓我們想像一個超級複雜的情況，有三個主題/插件和網站本身都試圖定義同一個組件。Docusaurus 在內部將這些主題加載為一個「堆疊」。

```text
+-------------------------------------------------+
|        `website/src/theme/CodeBlock.js`         | <-- `@theme/CodeBlock` always points to the top
+-------------------------------------------------+
| `theme-live-codeblock/theme/CodeBlock/index.js` | <-- `@theme-original/CodeBlock` points to the topmost non-swizzled component
+-------------------------------------------------+
|  `plugin-awesome-codeblock/theme/CodeBlock.js`  |
+-------------------------------------------------+
|     `theme-classic/theme/CodeBlock/index.js`    | <-- `@theme-init/CodeBlock` always points to the bottom
+-------------------------------------------------+
```

這個「堆疊」中的組件按照 `preset plugins > preset themes > plugins > themes > site` 的順序推入，因此 `website/src/theme` 中的替換組件總是在頂部，因為它是最後加載的。

`@theme/*` 始終指向最頂部的組件——當 `CodeBlock` 被替換時，所有請求 `@theme/CodeBlock` 的其他組件都會收到替換後的版本。

`@theme-original/*` 始終指向最頂部的非替換組件。這就是為什麼你可以在替換組件中導入 `@theme-original/CodeBlock`——它指向「組件堆疊」中的下一個組件，即主題提供的組件。插件作者不應嘗試使用這個，因為你的組件可能是最頂部的組件，從而導致自我導入。

`@theme-init/*` 始終指向最底部的組件——通常，這來自首次提供此組件的主題或插件。試圖增強代碼塊的單個插件/主題可以安全地使用 `@theme-init/CodeBlock` 來獲取其基本版本。網站創建者通常不應使用這個，因為你可能希望增強_最頂部_的組件，而不是_最底部_的組件。也有可能 `@theme-init/CodeBlock` 別名根本不存在——Docusaurus 只有在它指向與 `@theme-original/CodeBlock` 不同的組件時才會創建它，即當它由多個主題提供時。我們不會浪費別名！

## 客戶端模塊 {#client-modules}

Client modules are part of your site's bundle, just like theme components. However, they are usually side-effect-ful. Client modules are anything that can be `import`ed by Webpack—CSS, JS, etc. JS scripts usually work on the global context, like registering event listeners, creating global variables...

These modules are imported globally before React even renders the initial UI.

```js title="@docusaurus/core/App.tsx"
// How it works under the hood
import '@generated/client-modules';
```

Plugins and sites can both declare client modules, through [`getClientModules`](../api/plugin-methods/lifecycle-apis.mdx#getClientModules) and [`siteConfig.clientModules`](../api/docusaurus.config.js.mdx#clientModules), respectively.

Client modules are called during server-side rendering as well, so remember to check the [execution environment](./ssg.mdx#escape-hatches) before accessing client-side globals.

```js title="mySiteGlobalJs.js"
import ExecutionEnvironment from '@docusaurus/ExecutionEnvironment';

if (ExecutionEnvironment.canUseDOM) {
  // As soon as the site loads in the browser, register a global event listener
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Period') {
      location.assign(location.href.replace('.com', '.dev'));
    }
  });
}
```

CSS stylesheets imported as client modules are [global](../styling-layout.mdx#global-styles).

```css title="mySiteGlobalCss.css"
/* This stylesheet is global. */
.globalSelector {
  color: red;
}
```

### Client module lifecycles {#client-module-lifecycles}

Besides introducing side-effects, client modules can optionally export two lifecycle functions: `onRouteUpdate` and `onRouteDidUpdate`.

Because Docusaurus builds a single-page application, `script` tags will only be executed the first time the page loads, but will not re-execute on page transitions. These lifecycles are useful if you have some imperative JS logic that should execute every time a new page has loaded, e.g., to manipulate DOM elements, to send analytics data, etc.

For every route transition, there will be several important timings:

1. The user clicks a link, which causes the router to change its current location.
2. Docusaurus preloads the next route's assets, while keeping displaying the current page's content.
3. The next route's assets have loaded.
4. The new location's route component gets rendered to DOM.

`onRouteUpdate` will be called at event (2), and `onRouteDidUpdate` will be called at (4). They both receive the current location and the previous location (which can be `null`, if this is the first screen).

`onRouteUpdate` can optionally return a "cleanup" callback, which will be called at (3). For example, if you want to display a progress bar, you can start a timeout in `onRouteUpdate`, and clear the timeout in the callback. (The classic theme already provides an `nprogress` integration this way.)

Note that the new page's DOM is only available during event (4). If you need to manipulate the new page's DOM, you'll likely want to use `onRouteDidUpdate`, which will be fired as soon as the DOM on the new page has mounted.

```js title="myClientModule.js"
export function onRouteDidUpdate({location, previousLocation}) {
  // Don't execute if we are still on the same page; the lifecycle may be fired
  // because the hash changes (e.g. when navigating between headings)
  if (location.pathname !== previousLocation?.pathname) {
    const title = document.getElementsByTagName('h1')[0];
    if (title) {
      title.innerText += '❤️';
    }
  }
}

export function onRouteUpdate({location, previousLocation}) {
  if (location.pathname !== previousLocation?.pathname) {
    const progressBarTimeout = window.setTimeout(() => {
      nprogress.start();
    }, delay);
    return () => window.clearTimeout(progressBarTimeout);
  }
  return undefined;
}
```

Or, if you are using TypeScript and you want to leverage contextual typing:

```ts title="myClientModule.ts"
import type {ClientModule} from '@docusaurus/types';

const module: ClientModule = {
  onRouteUpdate({location, previousLocation}) {
    // ...
  },
  onRouteDidUpdate({location, previousLocation}) {
    // ...
  },
};
export default module;
```

Both lifecycles will fire on first render, but they will not fire on server-side, so you can safely access browser globals in them.

:::tip[Prefer using React]

Client module lifecycles are purely imperative, and you can't use React hooks or access React contexts within them. If your operations are state-driven or involve complicated DOM manipulations, you should consider [swizzling components](../swizzling.mdx) instead.

:::