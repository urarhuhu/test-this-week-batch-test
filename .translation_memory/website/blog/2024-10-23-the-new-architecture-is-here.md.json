{
  "source_file_path_relative_to_docusaurus_root": "blog/2024-10-23-the-new-architecture-is-here.md",
  "source_file_content_hash": "7bc59275d1138588e4f68d6b2af39ebb8230f6f4c228845a835bb7a7ce060c57",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\ntitle: 'New Architecture is here'\nauthors: [reactteam]\ntags: [announcement]\ndate: 2024-10-23T16:01\n---",
      "source_content_hash": "c8d8e3a69eaf810dd29a25835b406c9f23c6b4ec5938045caadd374c4f769fca",
      "node_type": "yaml",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "3fbbcc07",
      "source_content": "React Native 0.76 with the New Architecture by default is now available on npm!",
      "source_content_hash": "49d2462eebc3993d7165f21af4a3b6fd8ff7aced8ef6d71561a529ead717cf6b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7e5c5a39",
      "source_content": "In the [0.76 release blog post](/blog/2024/10/23/release-0.76-new-architecture), we shared a list of significant changes included in this version. In this post, we provide an overview of the New Architecture and how it shapes the future of React Native.",
      "source_content_hash": "5be3f759d6e041e7ee84b5ed46e92e1dd8830530fe24be4c399e7cc0ece643e8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "8d66f911",
      "source_content": "The New Architecture adds full support for modern React features, including [Suspense](https://react.dev/blog/2022/03/29/react-v18#new-suspense-features), [Transitions](https://react.dev/blog/2022/03/29/react-v18#new-feature-transitions), [automatic batching](https://react.dev/blog/2022/03/29/react-v18#new-feature-automatic-batching), and [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect). The New Architecture also includes new [Native Module](/docs/next/turbo-native-modules-introduction) and [Native Component](/docs/next/fabric-native-components-introduction) systems that let you write type-safe code with direct access to native interfaces without a bridge.",
      "source_content_hash": "3f43a85a198338c5f3434f64b96e93d64f9292f308e5558c202954ff366c7128",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ad8fd492",
      "source_content": "This release is the result of a ground-up rewrite of React Native we’ve been working on since 2018, and we’ve taken extra care to make the New Architecture a gradual migration for most apps. In 2021, we created [the New Architecture Working Group](https://github.com/reactwg/react-native-new-architecture/) to collaborate with the community on ensuring a smooth upgrade experience for the entire React ecosystem.",
      "source_content_hash": "d9a91575fb15afa592d23772a2ae58f1d04a98f63f54447c100e5aa8a56938ab",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "86b54d44",
      "source_content": "Most apps will be able to adopt React Native 0.76 with the same level of effort as any other release. The most popular React Native libraries already support the New Architecture. The New Architecture also includes an automatic interoperability layer to enable backward compatibility with libraries targeting the old architecture.",
      "source_content_hash": "f3b0ce7b0208154bf5a2d569ce05566a54052f2babc2d8df84d6402467f3f2cd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "45c63027",
      "source_content": "<!--truncate-->",
      "source_content_hash": "f5cded2aa7e288e395fe4f67f9dabda2281904b2f5358d07302b3aa8be0acdfa",
      "node_type": "comment",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "1acb9a05",
      "source_content": "Over the past several years of development, our team has publicly shared our vision for the New Architecture. If you missed any of these talks, check them out here:",
      "source_content_hash": "06793069a52b8baf7d7c929e0bcaf0e74d7ba6fd09191b9faa7ab6cf0b81dc5c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "da23c906",
      "source_content": "- [React Native EU 2019 - The New React Native](https://www.youtube.com/watch?v=52El0EUI6D0)\n- [React Conf 2021 - React 18 Keynote](https://www.youtube.com/watch?v=FZ0cG47msEk)\n- [App.js 2022 - Bringing the New React Native Architecture to the OSS Community](https://www.youtube.com/watch?v=Q6TkkzRJfUo)\n- [React Conf 2024 - Day 2 Keynote](https://www.youtube.com/watch?v=Q5SMmKb7qVI)",
      "source_content_hash": "f23f139cc372bbacc7b5d52c344958777bf1e31b07925fa3ec727e35ba67e404",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "fa430ad4",
      "source_content": "## What is the New Architecture",
      "source_content_hash": "b6cd507ab1b38804258e0c4de7b104e18a3f14367f0b6ff540d49e60f84593fe",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4b1d2d7d",
      "source_content": "The New Architecture is a complete rewrite of the major systems that underpin React Native, including how components are rendered, how JavaScript abstractions communicates with native abstractions, and how work is scheduled across different threads. Although most users should not have to think about how these systems work, these changes bring improvements and new capabilities.",
      "source_content_hash": "ddbabb12a9ac55354319441adddb2bdb61fb1477a0c5c74a9632d5d052295e11",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "dfe931a2",
      "source_content": "In the old architecture, React Native communicated with the native platform using an asynchronous bridge. To render a component or call a native function, React Native needed to serialize and enqueue native functions calls with the bridge, which would be processed asynchronously. The benefit of this architecture is that the main thread was never blocked for rendering updates or handling native module function calls, since all work was done on a background thread.",
      "source_content_hash": "6122be9dd828e875df3e328d5913d9699f38cdc74dc5b8963890df1ebab26946",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4daf5cdd",
      "source_content": "However, users expect immediate feedback to interactions to feel like a native app. This means some updates need to render synchronously in response to user input, potentially interrupting any in-progress render. Since the old architecture was only asynchronous, we needed to rewrite it to allow for both asynchronous and synchronous updates.",
      "source_content_hash": "e1ba66565e55c046b12f9a6d55b6751edb1492dca8d93504f01f52bf4cb078f5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "bdc231b1",
      "source_content": "Additionally, in the old architecture, serializing function calls over the bridge quickly became a bottleneck, especially for frequent updates or large objects. This made it hard for apps to achieve 60+ FPS reliably. There were also synchronization issues: when the JavaScript and native layer got out of sync, it was impossible to reconcile them synchronously, resulting bugs like lists showing frames of empty space and visual UI jumps due to intermediate states rendering.",
      "source_content_hash": "9a52c655673114c2e94d1019d2f81439272a7298604816cada95ae33233630e9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "97ae4a01",
      "source_content": "Finally, since the old architecture kept a single copy of the UI using the native hierarchy, and mutated that copy in place, layout could only be computed on a single thread. This made it impossible to process urgent updates like user inputs, and layout could not be read synchronously, such as reading in a layout effect to update the position of a tooltip.",
      "source_content_hash": "bee14f69b547e5988fb7a5133af513358fd797fbcd479e0d2301947627b4080f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "最後，由於舊架構使用原生層級結構保存單一 UI 副本並就地變更該副本，佈局計算僅能在單一執行緒上進行。這使得無法處理使用者輸入等緊急更新，且佈局無法同步讀取（例如在佈局效果中讀取以調整工具提示位置）。"
      }
    },
    {
      "segment_id": "c3a738de",
      "source_content": "All of these problems meant that it was not possible to properly support React’s concurrent features. To solve these problems, the New Architecture includes four main parts:",
      "source_content_hash": "aea8f302086f760430688054e47edcf5da81b9fa1ad20f7da71d5d8abca1d81e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "這些問題意味著無法完整支援 React 的並行功能。為解決這些問題，新架構包含四個主要部分："
      }
    },
    {
      "segment_id": "8a01ee7b",
      "source_content": "- The New Native Module System\n- The New Renderer\n- The Event Loop\n- Removing the Bridge",
      "source_content_hash": "43e0dbca7f7c8ba59802cb21a15751c1034d776b0ae4960a78adc4cb1b0379db",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 全新原生模組系統\n- 全新渲染器\n- 事件循環\n- 移除橋接層"
      }
    },
    {
      "segment_id": "8af76f3d",
      "source_content": "The New Module system allows the React Native Renderer to have synchronous access to the native layer, which allows it to handle events, schedule updates, and read layout both asynchronously and synchronously. The new Native Modules are also lazily loaded by default, giving apps a significant performance gain.",
      "source_content_hash": "3a9d08c6ea37fb27be50136bb5324b203cd314575059ef5f7c7d270ede70eea0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新模組系統讓 React Native 渲染器能同步存取原生層，使其能非同步/同步處理事件、調度更新與讀取佈局。新原生模組預設採用延遲載入，為應用程式帶來顯著效能提升。"
      }
    },
    {
      "segment_id": "a9d49f92",
      "source_content": "The New Renderer can handle multiple in progress trees across multiple threads, which allows React to process multiple concurrent update priorities, either on the main thread or a background thread. It also supports reading layout from multiple threads synchronously or asynchronously, to support more responsive UIs without jank.",
      "source_content_hash": "757e142cfde01c58cf40b33a63ba80b3f8f99f2a751c29f6bc9a9b0593734aef",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新渲染器能跨多執行緒處理多個進行中的樹狀結構，讓 React 可在主執行緒或背景執行緒處理多種並行更新優先級。同時支援從多執行緒同步/非同步讀取佈局，以實現更流暢的 UI 響應。"
      }
    },
    {
      "segment_id": "a44047a5",
      "source_content": "The new Event Loop can process tasks on the JavaScript thread in a well-defined order. This allows React to interrupt rendering to process events so urgent user events can take priority over lower priority UI transitions. The Event Loop also aligns with web specifications, so we can support for browser features like microtasks, `MutationObserver`, and `IntersectionObserver`.",
      "source_content_hash": "2c8432f5189d45eb5fbf9558791cde9cda095df898b8a8a7d535a60ffc0ecf43",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新事件循環能在 JavaScript 執行緒依明確定義的順序處理任務，使 React 可中斷渲染以優先處理緊急使用者事件。該循環也符合網頁規範，未來可支援微任務、`MutationObserver` 和 `IntersectionObserver` 等瀏覽器功能。"
      }
    },
    {
      "segment_id": "f7ef78f9",
      "source_content": "Finally, removing the bridge allows for faster startup and direct communication between JavaScript and the native runtime, so that the cost of switching work is minimized. This also allows for better error reporting, debugging, and reducing crashes from undefined behavior.",
      "source_content_hash": "7ea18e276ff646e5e6971c0d416da0391dd4e2f219aa753c84cbcc8b1bfc85a1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "移除橋接層能加速啟動時間，並實現 JavaScript 與原生運行時的直接通訊，最小化工作切換成本。同時改善錯誤報告、除錯能力，並減少未定義行為導致的崩潰。"
      }
    },
    {
      "segment_id": "b36c6338",
      "source_content": "The New Architecture is now ready to be used in production. It is already used at scale at Meta in the Facebook app and in other products. We successfully used React Native and the New Architecture in the Facebook and Instagram app we developed for our [Quest devices](https://engineering.fb.com/2024/10/02/android/react-at-meta-connect-2024/).",
      "source_content_hash": "da54374ed35c8c965087e19eb2a7eade2e4a658babb4205b4afb8a42c48bfaf3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新架構已具備生產環境使用成熟度，Meta 旗下 Facebook 等應用程式已大規模採用。我們在為 [Quest 裝置](https://engineering.fb.com/2024/10/02/android/react-at-meta-connect-2024/) 開發的 Facebook 和 Instagram 應用中成功運用此架構。"
      }
    },
    {
      "segment_id": "b9aaa519",
      "source_content": "Our partners have already been using the New Architecture in production for months now: have a look at these success stories by [Expensify](https://blog.swmansion.com/sunrising-new-architecture-in-the-new-expensify-app-729d237a02f5) and [Kraken](https://blog.kraken.com/product/engineering/how-kraken-fixed-performance-issues-via-incremental-adoption-of-the-react-native-new-architecture), and give [Bluesky](https://github.com/bluesky-social/social-app/releases/tag/1.92.0-na-rc.2) a shot with their new release.",
      "source_content_hash": "545906a87a8087fafba192d2bd13f465197a99e3e0a58a9b034ea943c16518a8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "合作夥伴已於生產環境採用新架構數月：[Expensify](https://blog.swmansion.com/sunrising-new-architecture-in-the-new-expensify-app-729d237a02f5) 與 [Kraken](https://blog.kraken.com/product/engineering/how-kraken-fixed-performance-issues-via-incremental-adoption-of-the-react-native-new-architecture) 的成功案例可供參考，另可試用 [Bluesky](https://github.com/bluesky-social/social-app/releases/tag/1.92.0-na-rc.2) 的新版本。"
      }
    },
    {
      "segment_id": "1a316f80",
      "source_content": "### New Native Modules",
      "source_content_hash": "fe57c61f570728a1277ccf5565cc9e42a88f8cc7add4b4e1c975b0f370148783",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 全新原生模組"
      }
    },
    {
      "segment_id": "40158b4b",
      "source_content": "The new Native Module System is a major rewrite of how JavaScript and the native platform communicate. It’s written entirely in C++, which unlocks many new capabilities:",
      "source_content_hash": "971417af897de96821c858c2bd0be246a08a0de938d48b0e685d24b42b1ef493",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新原生模組系統徹底改寫 JavaScript 與原生平台的通訊方式，完全以 C++ 編寫，實現以下新功能："
      }
    },
    {
      "segment_id": "24c174ca",
      "source_content": "- Synchronous access to and from the native runtime\n- Type safety between JavaScript and native code\n- Code sharing across platforms\n- Lazy module loading by default",
      "source_content_hash": "6631f416761682df8aec88cebd7dbc71a180a5e036dd4721a5869de0021fa7a3",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 與原生運行時的同步雙向存取\n- JavaScript 與原生程式碼間的型別安全\n- 跨平台程式碼共享\n- 預設延遲模組載入"
      }
    },
    {
      "segment_id": "0bb95128",
      "source_content": "In the new Native Module system, JavaScript and the native layer can now synchronously communicate with each other through the JavaScript Interface (JSI), without the need to use an asynchronous bridge. This means your custom Native Modules can now synchronously call a function, return a value, and pass that value back to another Native Module function.",
      "source_content_hash": "4e2a5805f4095bb2b544b64b7949b3b855b92934867fd61f886dd009f8a71ad6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在新系統中，JavaScript 與原生層能透過 JavaScript 介面 (JSI) 直接同步通訊，無需非同步橋接。這表示自訂原生模組現在可同步呼叫函式、回傳值並將值傳遞至其他原生模組函式。"
      }
    },
    {
      "segment_id": "657c2b20",
      "source_content": "In the old architecture, in order to handle a response from native function calls, you needed to provide a callback, and the value returned needed to be serializable:",
      "source_content_hash": "ca6b842aa3c57d83bc1ef30cbd796a37d10e9f9a10fe8548aa6560c9edfd7502",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "舊架構中，處理原生函式呼叫回應需提供回調函式，且回傳值需可序列化："
      }
    },
    {
      "segment_id": "17c579d2",
      "source_content": "```ts\n// ❌ Sync callback from Native Module\nnativeModule.getValue(value => {\n  // ❌ value cannot reference a native object\n  nativeModule.doSomething(value);\n});\n```",
      "source_content_hash": "7a7bdb6916c0a99fe3cfdc882b5c7680dc660196bd7fe8f1c66d7c11494ebf6f",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_17c579d2"
      }
    },
    {
      "segment_id": "e8e162a9",
      "source_content": "In the New Architecture, you can make synchronous calls to native functions:",
      "source_content_hash": "09f587ea33b413e8b8db986a842237cc16acdaa9965fb90ee92b99f47847bbb9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新架構允許直接同步呼叫原生函式："
      }
    },
    {
      "segment_id": "9f4336b3",
      "source_content": "```ts\n// ✅ Sync response from Native Module\nconst value = nativeModule.getValue();\n\n// ✅ value can be a reference to a native object\nnativeModule.doSomething(value);\n```",
      "source_content_hash": "4c73ff92ccef625f96aceded702df4546799bd8db3416632e627c4ae1dada1ce",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_9f4336b3"
      }
    },
    {
      "segment_id": "74dd7937",
      "source_content": "With the New Architecture, you can finally leverage the full power of a C++ native implementation while still accessing it from JavaScript/TypeScript APIs. The New Module System supports [modules written in C++](/docs/next/the-new-architecture/pure-cxx-modules) so you can write your module once, and it works across all platforms, including Android, iOS, Windows, and macOS. Implementing modules in C++ allows for more fine-grained memory management and performance optimizations.",
      "source_content_hash": "4aac931e67b96179c708b819921b5fa83aa3d79351fffbf20bd3134dd859317e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "新架構讓開發者能充分發揮 C++ 原生實現的效能，同時透過 JavaScript/TypeScript API 存取。新系統支援 [純 C++ 模組](/docs/next/the-new-architecture/pure-cxx-modules)，撰寫一次即可跨 Android、iOS、Windows 和 macOS 平台運作。C++ 實作能進行更精細的記憶體管理與效能優化。"
      }
    },
    {
      "segment_id": "5803caac",
      "source_content": "Additionally, with [Codegen](/docs/next/the-new-architecture/what-is-codegen), your modules can define a strongly typed contract between the JavaScript layer and the native layer. From our experience, cross-boundary type errors are one of the most common sources of crashes in cross-platform apps. Codegen lets you overcome those problems while also generating boilerplate code for you.",
      "source_content_hash": "1bb2c7ea7320ef8a4acf3c1747465dbf8ba01dd91e364b1746e00afa42bad941",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "51867d16",
      "source_content": "Finally, modules are now lazily loaded: they are loaded in memory only when they’re effectively needed rather than at startup. This reduces the app startup time and keeps it low as the application grows in complexity.",
      "source_content_hash": "cfa62b2edf08c44545330153a8e13842bb3e6f35c760b87ba0ea1ef64c14cf0a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "785750ac",
      "source_content": "Popular libraries such as [react-native-mmkv](https://github.com/mrousavy/react-native-mmkv) have already seen benefits from migrating to the new Native Modules:",
      "source_content_hash": "7411cf36274e3861ab2d655d9846c2660db0879e0ead5d00939585dd90828118",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d3daf362",
      "source_content": "> “The new Native Modules greatly simplified setup, autolinking, and initialization for `react-native-mmkv`. Thanks to the New Architecture, `react-native-mmkv` is now a pure C++ Native Module, which allows it to work on any platform. The new Codegen allows MMKV to be fully type-safe, which fixed a long-standing `NullPointerReference` issue by enforcing null-safety, and being able to call Native Module functions synchronously allowed us to replace custom JSI access with the new Native Module API.”\n>\n> [Marc Rousavy](https://twitter.com/mrousavy), creator of `react-native-mmkv`",
      "source_content_hash": "30eb2bb90b83c5b578a179d64a4a5bd02aa7258513d2dbc841a8b9e9a2ee3140",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "99d0dd9b",
      "source_content": "### New Renderer",
      "source_content_hash": "4aebdb643061cf34bedd639cefb8db203ec967bae91834bd8023d759d18569e0",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d79a4831",
      "source_content": "We've also completely rewritten the Native Renderer, adding several benefits:",
      "source_content_hash": "bf9450030b03cf095ebe31fe39285d38165a2784d3b92bd111492378fa0aa627",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "dea0598f",
      "source_content": "- Updates can be rendered on different threads at different priorities.\n- Layout can be read synchronously and across different threads.\n- The renderer is written in C++ and shared across all platforms.",
      "source_content_hash": "c9ea0ebf25e12e5c00e687f859d806cb4700ece93bacdadb92c335a18c46f7eb",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "0e80209e",
      "source_content": "The updated Native Renderer now stores the view hierarchy in an immutable tree structure. This means that the UI is stored in a way that cannot be changed directly, allowing for thread-safe processing of updates. This allows it to handle multiple in-progress trees, each representing a different version of the user interface. As a result, updates can be rendered in the background without blocking the UI (such as during transitions) or on the main thread (in response to user input).",
      "source_content_hash": "a52bcecf286e8bb59816ff1f511a17b8cdb9d0ab314ab0c5b828748acd87fd5e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7bc8bb24",
      "source_content": "By supporting multiple threads, React can interrupt a low-priority update to render an urgent one, such as those generated by user inputs, and then resume the low-priority update as needed. The new renderer can also read layout information synchronously and across different threads. This enables background computation for low-priority updates and synchronous reads when needed, such as repositioning a tooltip.",
      "source_content_hash": "e50746841242227aedd75e72e5bb66c3fd23de6775d53490f953588bea3fdc27",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "6693c38c",
      "source_content": "Finally, rewriting the renderer in C++ allows it to be shared across all platforms. This ensures that the same code runs on iOS, Android, Windows, macOS, and any other React Native-supported platform, providing consistent rendering capabilities without needing re-implementation for each platform.",
      "source_content_hash": "58a9d1e5b3ea75ebe11919dabe7c5c553398f642cbf7afdb38c1ca7b87b66548",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e9313fef",
      "source_content": "This is a significant step towards our [Many Platform Vision](/blog/2021/08/26/many-platform-vision). For example, View Flattening was an Android-only optimisation to avoid deep layout trees. The new renderer, with shared C++ core, [brings this feature to iOS](https://github.com/reactwg/react-native-new-architecture/discussions/110). This optimisation is automatic and does not require setup, it comes for free with the shared renderer.",
      "source_content_hash": "e0d4e97a9cdedfe1879fc86de630649320a3a165f5d2995061d97f18505aaa42",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "1b4de6df",
      "source_content": "With these changes, React Native now fully supports Concurrent React features like Suspense and Transitions, making it easier to build complex user interfaces that respond quickly to user input without jank, delays, or visual jumps. In the future, we will leverage these new capabilities to bring more improvements to built-in components such as FlatList and TextInput.",
      "source_content_hash": "372187732f2839659a0eee8287bfc4fac7c677cbbfc06e1eaa3666a7991beee3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "1958bc43",
      "source_content": "Popular libraries like [Reanimated](https://docs.swmansion.com/react-native-reanimated/) are already taking advantage of the New Renderer:",
      "source_content_hash": "73594b6afeedf2b6293af35924e90c462fc90e2da3bc4255c98cf4d44b3f43d5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "9acd4d0e",
      "source_content": "> “Reanimated 4, currently in development, introduces a new animation engine that works directly with the New Renderer, allowing it to handle animations and manage layout across different threads. The New Renderer’s design is what truly enables these features to be built without relying on numerous workarounds. Moreover, because it’s implemented in C++ and shared across platforms, large portions of Reanimated can be written once, reducing platform-specific issues, minimizing the codebase, and streamlining adoption for out-of-tree platforms.”\n>\n> [Krzysztof Magiera](https://x.com/kzzzf), creator of [Reanimated](https://docs.swmansion.com/react-native-reanimated/)",
      "source_content_hash": "e820f6b2f8940eb9e4c29b30e3315794c2aa386d3207a0dcbab6e9f69a77744c",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ed644f52",
      "source_content": "### The Event Loop",
      "source_content_hash": "bae88ff1f5be5f4ef01431059315e4f34cbe44713c951723afe86d42a5dc58aa",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b9331170",
      "source_content": "The New Architecture allowed us to implement a well-defined event loop processing model, as described in this [RFC](https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0744-well-defined-event-loop.md). This RFC follows the specifications described in the [HTML Standard](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model), and it describes how React Native should perform tasks on the JavaScript thread.",
      "source_content_hash": "86e885d270149ea1665b8c97239ff06cdf8908f1590ee3beb66d55bf431aa923",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "8fcdd6d4",
      "source_content": "Implementing a well-defined event loop closes gaps between React DOM and React Native: the behavior of a React Native application is now closer to the behavior of a React DOM application, making it easier to learn once, and write anywhere.",
      "source_content_hash": "3db1f5f60272e62448cd3b6d7ad7356f6f70f3cc14696192d9c4d02a89356e7f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "53aa2b95",
      "source_content": "The event loop brings many benefits to React Native:",
      "source_content_hash": "6bb6bec29a6ce60daa691fe27a9352db5db68a5b1e9bc4c1f6bae0ad1cdb6436",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d8460b5b",
      "source_content": "- The ability to interrupt rendering to process events and tasks\n- Closer alignment with web specifications\n- Foundation for more browser features",
      "source_content_hash": "45fbd1a90455e56700317c3260ff9254acc5e3eea5ebca0292956c2e1e520704",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "1ecf0882",
      "source_content": "With the Event Loop, React is able to predictably order updates and events. This allows React to interrupt a low priority update with an urgent user event, and the New Renderer allows us to render those updates independently.",
      "source_content_hash": "9ce0e73b80883e00de09cc22e0387d5d8704a9b514aa498bba7b15fe2af3bbd0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e77cf7c6",
      "source_content": "The Event Loops also aligns the behavior of events and task like timers with web specifications, which means React Native works more like what users are familiar with in the Web, and allows for better code sharing between React DOM and React Native.",
      "source_content_hash": "7cb79a4203ceb1f0da1883607ea0da58360a5b5afcb842bd2bde7ef338988e40",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "bb1346b6",
      "source_content": "It also allows for the implementation of more compliant browser features like microtasks, `MutationObserver`, and `IntersectionObserver`. These features are not ready to use in React Native yet, but we are working on bringing them to you in the future.",
      "source_content_hash": "4fc35912ba60e4cd102bd76728259fb790df8e807b6e4ae50fa319fc2b3a2ebb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "8664ed0b",
      "source_content": "Finally, the Event Loop and the New Renderer changes to support reading layout synchronously allow React Native to add proper support for `useLayoutEffect` to read layout information synchronously and update the UI in the same frame. This allows you to position elements correctly before they are displayed to the user.",
      "source_content_hash": "0b7cbf0337d4c8e3ba1d2521941e98ae57ab79aa0f6b645556e867f72a2c29a5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "9e90a9b3",
      "source_content": "See [`useLayoutEffect`](/blog/2024/10/23/the-new-architecture-is-here#uselayouteffect) for more details.",
      "source_content_hash": "9afc726335c20964a8782c716577137532a56c91ebc5b64a6e8def78324f5749",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "a0d0e29e",
      "source_content": "### Removing the Bridge",
      "source_content_hash": "ef36394429aef2b35b843d090b81250bd13a57f1710c49caca72017eaddf1133",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "be17ccc3",
      "source_content": "In the New Architecture, we've also fully removed React Native's dependency on the bridge, replacing it with direct, efficient communication between JavaScript and native code using JSI:",
      "source_content_hash": "989ab1632b5fd8e3a9852e7f92f251feb29f79700d9d040f94b0ce2e0d8fcb5a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ad3e22c6",
      "source_content": "![](/blog/assets/0.76-bridge-diagram.png)",
      "source_content_hash": "09dbb30f28cc1af1a704f5131f0fbdb3edaed39dab7e92b3c207703e316b6689",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "3e8f45da",
      "source_content": "Removing the bridge improves startup time by avoiding bridge initialization. For example, in the old architecture, in order to provide global methods to JavaScript, we would need to initialize a module in JavaScript on startup, causing a small delay in app startup time:",
      "source_content_hash": "83cdca9502b39c45eeca1907f8ddea804beba781b1ffbe9545fe5cec18e6616e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d58c5dc0",
      "source_content": "```js\n// ❌ Slow initialization\nimport {NativeTimingModule} from 'NativeTimingModule';\nglobal.setTimeout = timer => {\n  NativeTimingModule.setTimeout(timer);\n};\n\n// App.js\nsetTimeout(() => {}, 100);\n```",
      "source_content_hash": "615a7ce18eead7d5943864194722418f432d0052e9043c318144cc831ac70b90",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "0ddaa835",
      "source_content": "In the New Architecture, we can directly bind methods from C++:",
      "source_content_hash": "e2362e60aa904325397fde378f72fa9ef571c77c1e36e2408cf381de27536212",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b5ea89c4",
      "source_content": "```cpp\n// ✅ Initialize directly in C++\nruntime.global().setProperty(runtime, \"setTimeout\", createTimer);\n```",
      "source_content_hash": "71979c4d5658467042d9ab5aa32c59862dfa9d8244a9fdb1527e9911c5077985",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "ddf3de1d",
      "source_content": "```js\n// App.js\nsetTimeout(() => {}, 100);\n```",
      "source_content_hash": "f252834880b40eb089ac2f04379d98cb72e3f8c9df2131139acf82d079c3f994",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "dc72fd20",
      "source_content": "The rewrite also improves error reporting, particularly for JavaScript crashes at startup, and reduces crashes from undefined behavior. If crashes occur, the new [React Native DevTools](/docs/next/react-native-devtools) simplify debugging and support the New Architecture.",
      "source_content_hash": "cc716339f448e41f7693f182827a374e045a83d61f9751809a5dc67eeec959d3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "674abb31",
      "source_content": "The bridge remains for backward compatibility to support gradual migration to the New Architecture. In the future, we will remove the bridge code completely.",
      "source_content_hash": "dff713c176356d62eb94286ce4d8b101265a214ed46ade2d0333d98dbab41f2f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "c66e62ef",
      "source_content": "### Gradual Migration",
      "source_content_hash": "f127ad7c21209fb8d38477e516a45fb3f7e0adf311e5c2258b33e5a8d307adb4",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "fe25bd72",
      "source_content": "We expect most apps can upgrade to 0.76 with the same effort as any other release.",
      "source_content_hash": "98a7c2983a66de5a2101ff463b33397a752680289d3036505b36144d20aaef62",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "c8a6ab3e",
      "source_content": "When you upgrade to 0.76, the New Architecture and React 18 are enabled by default. However, to use concurrent features and gain the full benefits of the New Architecture, your app and libraries will need to be gradually migrated to fully support the New Architecture.",
      "source_content_hash": "26acec7b44d0d2b5059629d8355d2adc91c504f3f2d3d0379879650718058650",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "5cf1bce4",
      "source_content": "When you first upgrade, your app will run on the New Architecture with an automatic interoperability layer with the old architecture. For most apps, this will work without any changes, but there are [known limitations](https://github.com/reactwg/react-native-new-architecture/discussions/237) with the interop layer, as it does not support accessing custom Shadow Nodes or concurrent features.",
      "source_content_hash": "9df34d7b282ff472e2385c8e9d5b3e31f26e37fbe991ee29c0ac0ed91e4b0af4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "0427bb2b",
      "source_content": "To use concurrent features, apps will also need to be updated to support [Concurrent React](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react) by following the [Rules of React](https://react.dev/reference/rules). To migrate your JavaScript code to React 18 and its semantics, follow the [React 18 Upgrade guide](https://react.dev/blog/2022/03/08/react-18-upgrade-guide).",
      "source_content_hash": "a224c6a2b1b35809aafae0afe5962f461e5eb672ac6ede8d38dfad912bd60561",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4899bc54",
      "source_content": "The overall strategy is to get your application running on the New Architecture without breaking existing code. You can then gradually migrate your app at your own pace. For new surfaces that have migrated all modules to the New Architecture, you can start using concurrent features immediately. For existing surfaces, you may need to address some issues and migrate modules before adding concurrent features.",
      "source_content_hash": "22c0b94a7b2c8ca2c5c831fe4b21f5efe4095fc6584757f527e3f6b1035b9056",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b27c61de",
      "source_content": "We've collaborated with the most popular React Native libraries to ensure support for the New Architecture. More than 850 libraries are already compatible, including all libraries with over 200K weekly downloads (~10% of downloaded libraries). You can check library compatibility with the New Architecture on the [reactnative.directory](https://reactnative.directory) website:",
      "source_content_hash": "2ad7a6d8d9d2bd2cd077dae137ab1b7c91bb6b64acb37fc617ca811b8f2b2465",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "af016b8e",
      "source_content": "![](/blog/assets/0.76-directory.png)",
      "source_content_hash": "042f8eae23690839bb112b93c423adcd16905faa43f92cbc56f1642650ad897a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "3799844b",
      "source_content": "For more details on upgrading, see [How to Upgrade](/blog/2024/10/23/the-new-architecture-is-here#how-to-upgrade) below.",
      "source_content_hash": "1bba4fb066591ef8f8c805319e47a4dbbe3f06152893c0fb7eaba88455abee35",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "8159e12a",
      "source_content": "## New Features",
      "source_content_hash": "8ea62f1e51b3c12557720ee6efa3ccd14ca3e344a516c5c8565ab3a17df9a2f9",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "6e5d54a8",
      "source_content": "The New Architecture includes full support for React 18, concurrent features, and `useLayoutEffect` in React Native. For a full list of React 18 features, please see the [React 18 blog post](https://react.dev/blog/2021/12/17/react-conf-2021-recap#react-18-and-concurrent-features).",
      "source_content_hash": "c00241a950d5cfd3bd6036bdafe00ff64525d72d50ee2899435416ba3a7a1a6f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e29294bd",
      "source_content": "### Transitions",
      "source_content_hash": "b8d933a50ac33a50c4e1529f25352bdb3df33028d7a639f69e788729dd16a58b",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ebfad7e4",
      "source_content": "Transitions are a new concept in React 18 to distinguish between urgent and non-urgent updates.",
      "source_content_hash": "73fa6b2f5019865ffd4f2e086d120bff68ab7a3597753cfd6e6e7d4dce83dd7f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "41da8c12",
      "source_content": "- **Urgent updates** reflect direct interaction, like typing and pressing.\n- **Transition updates** transition the UI from one view to another.",
      "source_content_hash": "e6d8e5ef360f28fd6f1d8fbc61f285f487ea4e4f528e1c780a64f072152b87fa",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "eeeea5ce",
      "source_content": "Urgent updates need immediate response to match our intuitions about how physical objects behave. However, transitions are different because the user doesn’t expect to see every intermediate value on screen. In the New Architecture, React Native is able to support rendering urgent updates and transition updates separately.",
      "source_content_hash": "ab95a9c32ca82ae1540bcce7e7cbdd026fa45d2189b41aa64cffee4c1c19c0c6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e4d8cd8a",
      "source_content": "Typically, for the best user experience, a single user input should result in both an urgent update and a non-urgent one. Similar to ReactDOM, events like `press` or `change` are handled as urgent and rendered immediately. You can use the `startTransition` API inside an input event to inform React which updates are “transitions” and can be deferred to the background:",
      "source_content_hash": "0868ef76bc65bd47e30117726cb9beb515cd951c990c22bf318de6c6cf565c0c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ff27b4c2",
      "source_content": "```jsx\nimport {startTransition} from 'react';\n\n// Urgent: Show the slider value\nsetCount(input);\n\n// Mark any state updates inside as transitions\nstartTransition(() => {\n  // Transition: Show the results\n  setNumberOfTiles(input);\n});\n```",
      "source_content_hash": "1d8727d7590219559a2bd170e341aadb735884fdf6b84245b783dd18a5d1d3f5",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "18ca7861",
      "source_content": "Separating urgent events from transitions allows for a more responsive user interface, and a more intuitive user experience.",
      "source_content_hash": "328eb764e6653f45ce5923ea58c6aaa492adf9de1c36babde1265bd93d24ccd8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "85821ad3",
      "source_content": "Here's a comparison of the old architecture without transitions and the new architecture with transitions. Imagine that each tile isn't a trivial view with a background color, but a rich component containing images and other components that are expensive to render. **After** using `useTransition` you avoid thrashing your app with updates and falling behind.",
      "source_content_hash": "8e792d14e5073234bb0db772f0c895ebea685367ef7828ffa28b298c271feccb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "17d89a55",
      "source_content": "<div className=\"TwoColumns TwoFigures\">\n<figure>\n <img src=\"/img/new-architecture/without-transitions.gif\" alt=\"A video demonstrating an app rendering many views (tiles) according to a slider input. The views are rendered in batches as the slider is quickly adjusted from 0 to 1000.\" />\n <figcaption><b>Before:</b> rendering tiles without marking it as a transition.</figcaption>\n</figure>\n<figure>\n <img src=\"/img/new-architecture/with-transitions.gif\" alt=\"A video demonstrating an app rendering many views (tiles) according to a slider input. The views are rendered in batches as the slider is quickly adjusted from 0 to 1000. There are less batch renders in comparison to the next video.\" />\n <figcaption><b>After:</b> rendering tiles <em>with transitions</em> to interrupt in-progress renders of stale state.</figcaption>\n</figure>\n</div>",
      "source_content_hash": "f4ac4501ae4fc6878daa0c05dafc2ec488239b3694cb778e2036e3d251378f00",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "f211c69a",
      "source_content": "For more information, see [Support for Concurrent Renderer and Features](/docs/0.75/the-new-architecture/landing-page#support-for-concurrent-renderer-and-features).",
      "source_content_hash": "ca8d8fcf22648d0bf60e250bd183b05611ce0805b721496d8c9e158124580d38",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4147aea6",
      "source_content": "### Automatic Batching",
      "source_content_hash": "c5fff398d52711d44a562324cc6c9a642b922dc228296e53b80461c5bc6ad22a",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "43287462",
      "source_content": "When upgrading to the New Architecture, you will benefit from automatic batching from React 18.",
      "source_content_hash": "1886b035a3a4b6cb507c2cbb0b16a8d780b3351f3abc282f63d9d4b6af2ad5f8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "6dc3e423",
      "source_content": "Automatic batching allows React to batch together more state updates when rendering to avoid the rendering of intermediate states. This allows React Native to be faster and less susceptible to lags, without any additional code from the developer.",
      "source_content_hash": "aade944c1cd3883d5eb0445baf625cf08f7c726477ac7eb1e687c45c261b0969",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "741508d5",
      "source_content": "<div className=\"TwoColumns TwoFigures\">\n<figure>\n <img src=\"/img/new-architecture/legacy-renderer.gif\" alt=\"A video demonstrating an app rendering many views according to a slider input. The slider value is adjusted from 0 to 1000 and the UI slowly catches up to rendering 1000 views.\" />\n <figcaption><b>Before:</b> rendering frequent state updates with legacy renderer.</figcaption>\n</figure>\n<figure>\n <img src=\"/img/new-architecture/react18-renderer.gif\" alt=\"A video demonstrating an app rendering many views according to a slider input. The slider value is adjusted from 0 to 1000 and the UI resolves to 1000 views faster than the previous example, without as many intermediate states.\" />\n <figcaption><b>After:</b> rendering frequent state updates with <em>automatic batching</em>.</figcaption>\n</figure>\n</div>",
      "source_content_hash": "4c5407cb0a9cc59c6e7745b57825127589262afc51e39b76b19d15a36c8db9df",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "9c70c953",
      "source_content": "In the old architecture, more intermediate states are rendered, and the UI keeps updating even when the slider stops moving. The New Architecture, renders fewer intermediate states and completes the rendering much sooner thanks to automatically batching the updates.",
      "source_content_hash": "b43a2544090f994b6062a2d87213902e92d39fa30d7e80db15355b0375ec79ba",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "93f7c834",
      "source_content": "For more information, see [Support for Concurrent Renderer and Features](/docs/0.75/the-new-architecture/landing-page#support-for-concurrent-renderer-and-features).",
      "source_content_hash": "ca8d8fcf22648d0bf60e250bd183b05611ce0805b721496d8c9e158124580d38",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "fe3afe38",
      "source_content": "### useLayoutEffect",
      "source_content_hash": "a304a18e04bb75b8062fe67abeb7cad10eb40250627a890b2551294db23f9205",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "f50056c0",
      "source_content": "Building on the Event Loop and the ability to read layout synchronously, in the New Architecture we added proper support for `useLayoutEffect` in React Native.",
      "source_content_hash": "32aa9e35360db142bbb668a746f080a8572c73cdc6b6c19ec9be44058a496dcb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "30aa9816",
      "source_content": "In the old architecture, you needed to use the asynchronous `onLayout` event to read layout information of a view (which was also asynchronous). As a result there would be at least one frame where the layout was incorrect until the layout was read and updated, causing issues like tooltips placed in the wrong position:",
      "source_content_hash": "5da5b785a400fe92f791dbbccbfcda5250b8f79acacb75575323f630d8d60f8b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d76894b4",
      "source_content": "```tsx\n// ❌ async onLayout after commit\nconst onLayout = React.useCallback(event => {\n  // ❌ async callback to read layout\n  ref.current?.measureInWindow((x, y, width, height) => {\n    setPosition({x, y, width, height});\n  });\n}, []);\n\n// ...\n<ViewWithTooltip\n  onLayout={onLayout}\n  ref={ref}\n  position={position}\n/>;\n```",
      "source_content_hash": "c671caca1dcd030abcb9f66a641afedc18d081369a9e91a4e2bae368400f1aed",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "7fa65ec5",
      "source_content": "The New Architecture fixes this by allowing synchronous access to layout information in `useLayoutEffect`:",
      "source_content_hash": "4ea1a9e2f12bfe38596c110ae9f1b35df997e8a48d8c29e14f3d70dedc4850f6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ca8f8565",
      "source_content": "```tsx\n// ✅ sync layout effect during commit\nuseLayoutEffect(() => {\n  // ✅ sync call to read layout\n  const rect = ref.current?.getBoundingClientRect();\n  setPosition(rect);\n}, []);\n\n// ...\n<ViewWithTooltip ref={ref} position={position} />;\n```",
      "source_content_hash": "bb469a2ccd021709acfa70678967a8f0611def3782905bee9f22928d39a3dc48",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "6c4ea90c",
      "source_content": "This change allows you to read layout information synchronously and update the UI in the same frame, allowing you to position elements correctly before they are displayed to the user:",
      "source_content_hash": "117d9829ea7b19384d719f416ac998280c744920f4b2bcb3049a1fcc3d948735",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "c80643de",
      "source_content": "<div className=\"TwoColumns TwoFigures\">\n<figure>\n <img src=\"/img/new-architecture/async-on-layout.gif\" alt=\"A view that is moving to the corners of the viewport and center with a tooltip rendered either above or below it. The tooltip is rendered after a short delay after the view moves\" />\n <figcaption>In the old architecture, layout was read asynchronously in `onLayout`, causing the position of the tooltip to be delayed.</figcaption>\n</figure>\n<figure>\n <img src=\"/img/new-architecture/sync-use-layout-effect.gif\" alt=\"A view that is moving to the corners of the viewport and center with a tooltip rendered either above or below it. The view and tooltip move in unison.\" />\n <figcaption>In the New Architecture, layout can be read in `useLayoutEffect` synchronously, updating the tooltip position before displaying.</figcaption>\n</figure>\n</div>",
      "source_content_hash": "edaed6a773e9b0b25213deb4c95a4a8d0b2eb4362739df95377cff0fa77849ef",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "83d7d3bc",
      "source_content": "For more information, see the docs for [Synchronous Layout and Effects](/docs/0.75/the-new-architecture/landing-page#synchronous-layout-and-effects).",
      "source_content_hash": "33199514ffe0d520aed8543c4b3e6988648596381b0fb157d454db82c7c1e0a6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "8e437dbf",
      "source_content": "### Full Support for Suspense",
      "source_content_hash": "0b9cf2c97cee2da1a10cb892831117be3b9edb879b6f793d9a5296563e51d1f4",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "c9f6a516",
      "source_content": "Suspense lets you declaratively specify the loading state for a part of the component tree if it’s not yet ready to be displayed:",
      "source_content_hash": "06dfcfb9d5692ba91e41c3389fce64881cf19e4fe4969b906f019518042b0ee8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4aede6b2",
      "source_content": "```jsx\n<Suspense fallback={<Spinner />}>\n  <Comments />\n</Suspense>\n```",
      "source_content_hash": "34931e7899eb113e26a081594e74053ac5aacca99d1b5d476d2a0fc6825951a2",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "71e7acda",
      "source_content": "We introduced a limited version of Suspense several years ago, and React 18 added full support. Until now, React Native was not able to support concurrent rendering for Suspense.",
      "source_content_hash": "df0e86ba48a9f6b1a8e6685e10d7939f134c50e53e106e8a697f65ccbdc9b59a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "0974dfbb",
      "source_content": "The New Architecture includes full support for Suspense introduced in React 18. This means that you can now use Suspense in React Native to handle loading states for your components, and the suspended content will render in the background while the loading state is displayed, giving higher priority to user input on visible content.",
      "source_content_hash": "a04e8bab050703978efb833c9ad8d291b8b83ba889c03b9cac5022d7b0c383c7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "a6c4ab41",
      "source_content": "For more, see the [RFC for Suspense in React 18](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md).",
      "source_content_hash": "5380bd628f1e59f732e4c3600114df61865714ec09f0ca06707d61475eda60c6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7901dac3",
      "source_content": "## How to Upgrade",
      "source_content_hash": "dd8685560dff343e65e179d364c4cca94a56086419e137d74ca2e88c39ce5c13",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4443801b",
      "source_content": "To upgrade to 0.76, follow the steps in the [release post](/blog/2024/10/23/release-0.76-new-architecture#upgrade-to-076). Since this release also upgrades to React 18, you will also need to follow the [React 18 Upgrade guide](https://react.dev/blog/2022/03/08/react-18-upgrade-guide).",
      "source_content_hash": "15e23533ad297b8a6532c046bc9dbb53574c75518d4672aa89803e3ef2a5c4d7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7441a9ec",
      "source_content": "These steps should be enough for most apps to upgrade to the New Architecture thanks to the interop layer with the old architecture. However, to take full advantage of the New Architecture and to start using concurrent features, you will need to migrate your custom Native Modules and Native Components to support the new Native Module and Native Component APIs.",
      "source_content_hash": "2f3be82d3decf9f17a6954d0496296784a3a7517611fc1b17313c0bd0644b237",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "a30b7214",
      "source_content": "Without migrating your custom Native Modules, you will not get the benefits of shared C++, synchronous method calls, or type-safety from codegen. Without migrating your Native Components, you will not be able to use concurrent features. We recommend migrating all Native Components and Native Modules to the New Architecture as soon as possible.",
      "source_content_hash": "51552a88697997a3ca7031f7ede5d2066daa96468bde275574a9a747936437a7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e60e7357",
      "source_content": ":::note\nIn a future release, we will remove the interop layer and modules will need to support the New Architecture.\n:::",
      "source_content_hash": "0300d0c3261dea70bc55956a6e9f169f572fa6df7b8e75ad8af7fc91e64d79d1",
      "node_type": "containerDirective",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "06c38a62",
      "source_content": "### Apps",
      "source_content_hash": "0c7f066a87def277dacde951ac5a0136725412ad45073af95f69ad79d3d41b99",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b3b952f2",
      "source_content": "If you are an app developer, to fully support the New Architecture, you will need to upgrade your libraries, custom Native Components, and custom Native Modules to fully support the New Architecture.",
      "source_content_hash": "acf8f73951013c09fc1085662d75f71a5caa9647e2f48623754021c9c2494063",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e17d0554",
      "source_content": "We've collaborated with the most popular React Native libraries to ensure support for the New Architecture. You can check library compatibility with the New Architecture on the [reactnative.directory](https://reactnative.directory) website.",
      "source_content_hash": "ebe292d3e0ea0150f1843926f019e1fbea81462aa42948a34d1c3652b56d0b7a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "44fd9885",
      "source_content": "If any of the libraries your app depends on are not compatible yet, you can:",
      "source_content_hash": "70edd3040317f742f8b97ea2f6d4e89b618821b06798f2481b99af179a7aa53c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e4073107",
      "source_content": "- Open an issue with the library and ask the author to migrate to the New Architecture.\n- If the library is not maintained, consider alternative libraries with the same features.\n- [Opt-out from the New Architecture](/blog/2024/10/23/the-new-architecture-is-here#opt-out) while those libraries are migrated.",
      "source_content_hash": "f14d43dc95af679f6b83bea5470b32311dc71e02352d639feebe2ba9c577553d",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "3d5e3f4c",
      "source_content": "If your app has custom Native Modules or custom Native Components, we expect them to work fine, thanks to our [interop layer](https://github.com/reactwg/react-native-new-architecture/discussions/135). However, we recommend upgrading them to the new Native Module and Native Component APIs to fully support the New Architecture and adopt concurrent features.",
      "source_content_hash": "c5d4c8665606f31d5ab488807db1e5a0effa0929d500444b96598ffa38cc53f3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "4667c154",
      "source_content": "Please follow these guides to migrate your modules and components to the New Architecture:",
      "source_content_hash": "5d329a8d0c6b28e90a830a7468e5da9d6a3a7dad04738e31f49d415285be42bf",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e954eee0",
      "source_content": "- [Native Modules](/docs/next/turbo-native-modules-introduction)\n- [Native Components](/docs/next/fabric-native-components-introduction)",
      "source_content_hash": "4bd7fb7d525fcabfdc3f1fd8e713ccdacc25deb9077efbc492f83a576b415f89",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ef0eaf79",
      "source_content": "### Libraries",
      "source_content_hash": "c1b62a2c7a23848c3deee82529e5811fc97d0ca5f9e615935485002e9c75d11e",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "227b5df5",
      "source_content": "If you are a library maintainer, please first test that your library works with the interop layer. If it does not, please open an issue on the [New Architecture Working Group](https://github.com/reactwg/react-native-new-architecture/).",
      "source_content_hash": "8f0cbc19ab24e2043f2804664b65c6d5a8066a9290b7b32fe2e3693cb2012e98",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "56f32447",
      "source_content": "To fully support the New Architecture, we recommend migrating your library to the new Native Module and Native Component APIs as soon as possible. This will allow users of your library to take full advantage of the New Architecture and support concurrent features.",
      "source_content_hash": "eefe72f0616c79e56a0b60a9fb92a7dcfd6ef2bc7b0ce2657b49ba2fbdf18baa",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b41b4d77",
      "source_content": "You can follow these guides to migrate your modules and components to the New Architecture:",
      "source_content_hash": "a128d4c4e0080d62955e553cd59b3f86c138bea5c6a92b281c4a01249fd72f13",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "889194b9",
      "source_content": "- [Native Modules](/docs/next/turbo-native-modules-introduction)\n- [Native Components](/docs/next/fabric-native-components-introduction)",
      "source_content_hash": "4bd7fb7d525fcabfdc3f1fd8e713ccdacc25deb9077efbc492f83a576b415f89",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "f7420cb5",
      "source_content": "### Opt-out",
      "source_content_hash": "801a8b391d0583c91a52244e8913bd403984b1152d9ddcbb8626ec4fab03e9c0",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "dbea1fe8",
      "source_content": "If, for any reason, the New Architecture is not behaving properly in your application, there is always the option to opt-out from it until you are ready to turn it on again.",
      "source_content_hash": "a4ffaecad0017f4e4391a0cf4d6b35c462ece5c3a862849686972ac0cf31fa01",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ebea2db8",
      "source_content": "To opt-out from the New Architecture:",
      "source_content_hash": "18790c626814fc074400e7f7f4731f3a103cab749b6f204f266940c10f30a5d4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "c9f5db52",
      "source_content": "- On Android, modify the `android/gradle.properties` file and turn off the `newArchEnabled` flag",
      "source_content_hash": "01ead4ef1f41a0f831145176009f39ae5acab9eac2188e87bd8662e6a59ea8e5",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "ac44b68f",
      "source_content": "```diff title=”gradle.properties”\n-newArchEnabled=true\n+newArchEnabled=false\n```",
      "source_content_hash": "6a2ccf43938667feccb56eaf28ea2f0f405d66ff5c54f9e68c74d532ce4cf169",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "1c7ed9a5",
      "source_content": "- On iOS, you can reinstall the dependencies by running the command:",
      "source_content_hash": "5720b979452543be44524f24532a9d5caf8a01dc7d3c814803c357d1a8b70dab",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d1c28c8f",
      "source_content": "```shell\nRCT_NEW_ARCH_ENABLED=0 bundle exec pod install\n```",
      "source_content_hash": "11dcc65000ba8a1bc2a9ff900a7d141e3ca6fa0fe912ea67277ccdf36dd062af",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "bbee8ddc",
      "source_content": "## Thanks",
      "source_content_hash": "1e57366f4f2b8342ce1186455878164e2c099d41b453de456c1a921520e0df59",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "e3f3475c",
      "source_content": "Delivering the New Architecture to the OSS community has been a huge effort that took us several years of research and development. We want to take a moment to thank all the current and past members of the React team who helped us achieve this result.",
      "source_content_hash": "05db025d8661918bdd6af05c0c845c31336cb68ffc415b676a319394f2db8a6d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b63b9ccf",
      "source_content": "We are also extremely grateful to all the partners who collaborated with us to make this happen. Specifically, we would like to call out:",
      "source_content_hash": "32181f159a438f283a3a21e241ff449052c62e40daafa7201325bca8130238fd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "0a48254a",
      "source_content": "- [Expo](https://expo.dev/), for adopting the New Architecture early on, and for supporting the work on migrating the most popular libraries.\n- [Software Mansion](https://swmansion.com/), for maintaining crucial libraries in the ecosystem, for migrating them to the New Architecture early and for all the help in investigating and fixing various issues.\n- [Callstack](https://www.callstack.com/), for maintaining crucial libraries in the ecosystem, for migrating them to the New Architecture early and for the support with the work on the Community CLI.\n- [Microsoft](https://opensource.microsoft.com/), for adding the New Architecture implementation for `react-native-windows` and `react-native-macos` as well as in several other developer tools.\n- [Expensify](https://www.expensify.com/), [Kraken](https://www.kraken.com/), [Bluesky](https://bsky.app/) and [Brigad](https://www.brigad.co/) for pioneering the adoption of the New Architecture and reporting various issues so that we could fix them for everyone else.\n- All the independent library maintainers and developers who contributed to the New Architecture by testing it, fixing some of the issues, and opening questions on unclear matters so that we could clear them.",
      "source_content_hash": "f05d636d416171be764ab495b0123207111f62705c269d0746c343129de9db42",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-blog/2024-10-23-the-new-architecture-is-here.md",
  "last_updated_timestamp": "2025-06-18T10:03:59.228434+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "7bc59275d1138588e4f68d6b2af39ebb8230f6f4c228845a835bb7a7ce060c57"
  }
}