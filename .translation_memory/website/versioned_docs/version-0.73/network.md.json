{
  "source_file_path_relative_to_docusaurus_root": "versioned_docs/version-0.73/network.md",
  "source_file_content_hash": "90b5aaf52137379ff5a2c180295dd8f50a4eb679643efcac7a3e66454f9296a5",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\nid: network\ntitle: Networking\n---",
      "source_content_hash": "4f0c11385939fa8478c518a911be910dd501ff0de636105ef1ded29d5be2b522",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_58cfcc64"
      }
    },
    {
      "segment_id": "4d1292be",
      "source_content": "import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import constants from '@site/core/TabsConstants';",
      "source_content_hash": "0aed60180598135363f970d0b23d8d7665430a4b05f703a572a064dbbca30b07",
      "node_type": "mdxjsEsm",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_4d1292be"
      }
    },
    {
      "segment_id": "3fbbcc07",
      "source_content": "Many mobile apps need to load resources from a remote URL. You may want to make a POST request to a REST API, or you may need to fetch a chunk of static content from another server.",
      "source_content_hash": "887b3fd5ca322dce4d2979469e96dcd99b41a36b0eb0c6c8a643cc80744b93d2",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "許多行動應用程式需要從遠端URL加載資源。您可能需要向REST API發送POST請求，或是從其他伺服器獲取靜態內容片段。"
      }
    },
    {
      "segment_id": "1cc03ec8",
      "source_content": "## Using Fetch",
      "source_content_hash": "a0608b2d9310d79be1b3df9befed4eeeb3222edec623c3d797f88838a3846016",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 使用Fetch"
      }
    },
    {
      "segment_id": "8d66f911",
      "source_content": "React Native provides the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for your networking needs. Fetch will seem familiar if you have used `XMLHttpRequest` or other networking APIs before. You may refer to MDN's guide on [Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) for additional information.",
      "source_content_hash": "74c24e3714004fc5e9df160b8cec8b384d4f3b9d69a9ba09f3b5d93e3d636718",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "React Native提供[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)來滿足您的網路需求。如果您曾使用過`XMLHttpRequest`或其他網路API，Fetch會讓您感到熟悉。您可以參考MDN的[使用Fetch指南](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)獲取更多資訊。"
      }
    },
    {
      "segment_id": "70153c6e",
      "source_content": "### Making requests",
      "source_content_hash": "55429fb6d2319aa2c06dd69c524f236c3d1c66868365d56ec86616b9f428baa5",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 發送請求"
      }
    },
    {
      "segment_id": "86b54d44",
      "source_content": "In order to fetch content from an arbitrary URL, you can pass the URL to fetch:",
      "source_content_hash": "56a8a8fdf3f4087220d8a34caddc95f97d07d5b35c3ee08c4a6186c044b36873",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "要從任意URL獲取內容，只需將URL傳遞給fetch："
      }
    },
    {
      "segment_id": "6e5ba8fb",
      "source_content": "```tsx\nfetch('https://mywebsite.com/mydata.json');\n```",
      "source_content_hash": "02379f4ce77f598ee1f85d207b168f36d8869e1f5a733f201e6133392ae298d4",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_6e5ba8fb"
      }
    },
    {
      "segment_id": "2df4f75f",
      "source_content": "Fetch also takes an optional second argument that allows you to customize the HTTP request. You may want to specify additional headers, or make a POST request:",
      "source_content_hash": "c8a022ca81c587253cecf52ba1d2b91b5a667ccf31f1f616862181f305d0f950",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "Fetch還接受可選的第二個參數，允許您自訂HTTP請求。您可以指定額外的標頭或發送POST請求："
      }
    },
    {
      "segment_id": "f2b711c6",
      "source_content": "```tsx\nfetch('https://mywebsite.com/endpoint/', {\n  method: 'POST',\n  headers: {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    firstParam: 'yourValue',\n    secondParam: 'yourOtherValue',\n  }),\n});\n```",
      "source_content_hash": "7b92ecdb8691414e61d22764401f13685e42b1fe08a1576dcb7100a92e362a94",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f2b711c6"
      }
    },
    {
      "segment_id": "135468ee",
      "source_content": "Take a look at the [Fetch Request docs](https://developer.mozilla.org/en-US/docs/Web/API/Request) for a full list of properties.",
      "source_content_hash": "651b8c94689a04adda755a8d53ddf4295aaab11b08f875c870d322e716b21a6a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "請查閱[Fetch請求文檔](https://developer.mozilla.org/en-US/docs/Web/API/Request)獲取完整的屬性列表。"
      }
    },
    {
      "segment_id": "782c902a",
      "source_content": "### Handling the response",
      "source_content_hash": "31bbd70625e0c174c3ba8bea52c4907f67f1db3bf484e72a4c136c9e58dce5f3",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 處理回應"
      }
    },
    {
      "segment_id": "50746522",
      "source_content": "The above examples show how you can make a request. In many cases, you will want to do something with the response.",
      "source_content_hash": "de7be5e5ba5c965c47ac84c81855b0abce75de4de556a3c4ecd5811ee14c3137",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "上述範例展示了如何發送請求。在多數情況下，您會需要對回應進行處理。"
      }
    },
    {
      "segment_id": "95e9ba12",
      "source_content": "Networking is an inherently asynchronous operation. Fetch method will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that makes it straightforward to write code that works in an asynchronous manner:",
      "source_content_hash": "09ea35d7e305ae613fc41acf6a9c9149fdf5e31ccfcaf92c3f0cca1381380db5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "網路請求本質上是非同步操作。Fetch方法會返回一個[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)，讓您能輕鬆編寫非同步程式碼："
      }
    },
    {
      "segment_id": "4ec2920d",
      "source_content": "```tsx\nconst getMoviesFromApi = () => {\n  return fetch('https://reactnative.dev/movies.json')\n    .then(response => response.json())\n    .then(json => {\n      return json.movies;\n    })\n    .catch(error => {\n      console.error(error);\n    });\n};\n```",
      "source_content_hash": "860c86996a7977c5caef1bcccb2bae037208572b3e532c0bdb3a3704cfc790c5",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_4ec2920d"
      }
    },
    {
      "segment_id": "23dfb152",
      "source_content": "You can also use the `async` / `await` syntax in a React Native app:",
      "source_content_hash": "fb1afcbdcbff57950016431899fe97a32e2502da80a0981a5bc9662689a885b4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "您也可以在React Native應用中使用`async`/`await`語法："
      }
    },
    {
      "segment_id": "c05ad55e",
      "source_content": "```tsx\nconst getMoviesFromApiAsync = async () => {\n  try {\n    const response = await fetch(\n      'https://reactnative.dev/movies.json',\n    );\n    const json = await response.json();\n    return json.movies;\n  } catch (error) {\n    console.error(error);\n  }\n};\n```",
      "source_content_hash": "ae21505d5ab12b19997d57c5b133f03861160eeaff9da8e68db73113c30de716",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_c05ad55e"
      }
    },
    {
      "segment_id": "f01228d3",
      "source_content": "Don't forget to catch any errors that may be thrown by `fetch`, otherwise they will be dropped silently.",
      "source_content_hash": "5888fd8b54623d309f8648641893d20797e519d0e2d07f468f0031a2e9694766",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "請務必捕獲`fetch`可能拋出的錯誤，否則這些錯誤會被靜默忽略。"
      }
    },
    {
      "segment_id": "568a7359",
      "source_content": "<Tabs groupId=\"language\" queryString defaultValue={constants.defaultSnackLanguage} values={constants.snackLanguages}>\n<TabItem value=\"javascript\">\n\n```SnackPlayer name=Fetch%20Example&ext=js\nimport React, {useEffect, useState} from 'react';\nimport {ActivityIndicator, FlatList, Text, View} from 'react-native';\n\nconst App = () => {\n  const [isLoading, setLoading] = useState(true);\n  const [data, setData] = useState([]);\n\n  const getMovies = async () => {\n    try {\n      const response = await fetch('https://reactnative.dev/movies.json');\n      const json = await response.json();\n      setData(json.movies);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    getMovies();\n  }, []);\n\n  return (\n    <View style={{flex: 1, padding: 24}}>\n      {isLoading ? (\n        <ActivityIndicator />\n      ) : (\n        <FlatList\n          data={data}\n          keyExtractor={({id}) => id}\n          renderItem={({item}) => (\n            <Text>\n              {item.title}, {item.releaseYear}\n            </Text>\n          )}\n        />\n      )}\n    </View>\n  );\n};\n\nexport default App;\n```\n\n</TabItem>\n<TabItem value=\"typescript\">\n\n```SnackPlayer name=Fetch%20Example&ext=tsx\nimport React, {useEffect, useState} from 'react';\nimport {ActivityIndicator, FlatList, Text, View} from 'react-native';\n\ntype Movie = {\n  id: string;\n  title: string;\n  releaseYear: string;\n};\n\nconst App = () => {\n  const [isLoading, setLoading] = useState(true);\n  const [data, setData] = useState<Movie[]>([]);\n\n  const getMovies = async () => {\n    try {\n      const response = await fetch('https://reactnative.dev/movies.json');\n      const json = await response.json();\n      setData(json.movies);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    getMovies();\n  }, []);\n\n  return (\n    <View style={{flex: 1, padding: 24}}>\n      {isLoading ? (\n        <ActivityIndicator />\n      ) : (\n        <FlatList\n          data={data}\n          keyExtractor={({id}) => id}\n          renderItem={({item}) => (\n            <Text>\n              {item.title}, {item.releaseYear}\n            </Text>\n          )}\n        />\n      )}\n    </View>\n  );\n};\n\nexport default App;\n```\n\n</TabItem>\n</Tabs>",
      "source_content_hash": "fe8e11b869dee4f42ea34dfe2b2c79e2c7449b4144ce8fcbf05733ee1b2b4ac5",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_568a7359"
      }
    },
    {
      "segment_id": "7f8a39ef",
      "source_content": "> By default, iOS 9.0 or later enforce App Transport Security (ATS). ATS requires any HTTP connection to use HTTPS. If you need to fetch from a cleartext URL (one that begins with `http`) you will first need to [add an ATS exception](integration-with-existing-apps.md#test-your-integration). If you know ahead of time what domains you will need access to, it is more secure to add exceptions only for those domains; if the domains are not known until runtime you can [disable ATS completely](publishing-to-app-store.md#1-enable-app-transport-security). Note however that from January 2017, [Apple's App Store review will require reasonable justification for disabling ATS](https://forums.developer.apple.com/thread/48979). See [Apple's documentation](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33) for more information.",
      "source_content_hash": "6f54cf3c9486a65cde601a66544775fc9709eb72b40c110eb79a16e4c01dc25f",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> 預設情況下，iOS 9.0及以上版本強制實施App Transport Security (ATS)。ATS要求所有HTTP連接必須使用HTTPS。如果您需要從明文URL（以`http`開頭）獲取資料，首先需要[添加ATS例外](integration-with-existing-apps.md#test-your-integration)。如果事先知道需要訪問的網域，僅為這些網域添加例外會更安全；如果網域在運行時才確定，您可以[完全禁用ATS](publishing-to-app-store.md#1-enable-app-transport-security)。但請注意，自2017年1月起，[Apple的App Store審核會要求提供禁用ATS的合理理由](https://forums.developer.apple.com/thread/48979)。詳見[Apple文檔](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33)。"
      }
    },
    {
      "segment_id": "86f43d60",
      "source_content": "> On Android, as of API Level 28, clear text traffic is also blocked by default. This behaviour can be overridden by setting [`android:usesCleartextTraffic`](https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic) in the app manifest file.",
      "source_content_hash": "acd219b6c5d69983d4d89fe9833e1b7e42aadb52409f00455c226bf6c7a28a27",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> 在Android上，從API Level 28開始，預設也會阻止明文流量。可以通過在應用清單文件中設置[`android:usesCleartextTraffic`](https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic)來覆蓋此行為。"
      }
    },
    {
      "segment_id": "e63d69ef",
      "source_content": "## Using Other Networking Libraries",
      "source_content_hash": "69ff412b0ff7158b7da084105584b76abd0ee6f0cb9338640e400ea0b5852175",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 使用其他網路庫"
      }
    },
    {
      "segment_id": "0427bb2b",
      "source_content": "The [XMLHttpRequest API](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) is built into React Native. This means that you can use third party libraries such as [frisbee](https://github.com/niftylettuce/frisbee) or [axios](https://github.com/axios/axios) that depend on it, or you can use the XMLHttpRequest API directly if you prefer.",
      "source_content_hash": "3080db539dbadbfe895ac9bc57ab7c1d5dc576cb0314b90e8c1c3fc29b3a7c80",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "[XMLHttpRequest API](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)已內建於React Native中。這意味著您可以使用依賴它的第三方庫，如[frisbee](https://github.com/niftylettuce/frisbee)或[axios](https://github.com/axios/axios)，也可以直接使用XMLHttpRequest API。"
      }
    },
    {
      "segment_id": "0152e600",
      "source_content": "```tsx\nconst request = new XMLHttpRequest();\nrequest.onreadystatechange = e => {\n  if (request.readyState !== 4) {\n    return;\n  }\n\n  if (request.status === 200) {\n    console.log('success', request.responseText);\n  } else {\n    console.warn('error');\n  }\n};\n\nrequest.open('GET', 'https://mywebsite.com/endpoint/');\nrequest.send();\n```",
      "source_content_hash": "fc2cc4671489f9917e44008e4c35942d4d4efce80f7151cec57bf6683e7262c4",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_0152e600"
      }
    },
    {
      "segment_id": "c98c82d6",
      "source_content": "> The security model for XMLHttpRequest is different than on web as there is no concept of [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) in native apps.",
      "source_content_hash": "e38dd5a3710b4e8b1ef08fa458cec6e69080ec607295ed68faa7234d0e279826",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> XMLHttpRequest的安全模型與網頁不同，因為原生應用中沒有[CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)的概念。"
      }
    },
    {
      "segment_id": "197e1a1b",
      "source_content": "## WebSocket Support",
      "source_content_hash": "4a64aabd4372d8008dcd67cd9aa7f3c1a9bb60f6c85e5df412fd28a8359bfd36",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## WebSocket支援"
      }
    },
    {
      "segment_id": "09512450",
      "source_content": "React Native also supports [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket), a protocol which provides full-duplex communication channels over a single TCP connection.",
      "source_content_hash": "8c56cae49662521d7030f8d77c71d5ca3d61f38b6b0d89798f8617545c393422",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "React Native 也支援 [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)，這是一種透過單一 TCP 連線提供全雙工通訊通道的協定。"
      }
    },
    {
      "segment_id": "af7c5c4e",
      "source_content": "```tsx\nconst ws = new WebSocket('ws://host.com/path');\n\nws.onopen = () => {\n  // connection opened\n  ws.send('something'); // send a message\n};\n\nws.onmessage = e => {\n  // a message was received\n  console.log(e.data);\n};\n\nws.onerror = e => {\n  // an error occurred\n  console.log(e.message);\n};\n\nws.onclose = e => {\n  // connection closed\n  console.log(e.code, e.reason);\n};\n```",
      "source_content_hash": "a1904d2e7ff6bb7004b6739c7387ed7c99123e33d923c436238099a2122cb2d5",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_af7c5c4e"
      }
    },
    {
      "segment_id": "ad8a5f54",
      "source_content": "## Known Issues with `fetch` and cookie based authentication",
      "source_content_hash": "52c123941162c1a509da6c2057779764586e695e7ac184fcc7b37a2005c6745b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 已知 `fetch` 與基於 cookie 驗證的問題"
      }
    },
    {
      "segment_id": "4033c370",
      "source_content": "The following options are currently not working with `fetch`",
      "source_content_hash": "0c01328b35b9a3fc71b9910620e994bf7d33e14a7bf722f36de383a843ceb0ca",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "以下選項目前在 `fetch` 中無法正常運作："
      }
    },
    {
      "segment_id": "e286c122",
      "source_content": "- `redirect:manual`\n- `credentials:omit`",
      "source_content_hash": "f766e1de3837f06c114f2991f7e124a3f1e447ceb38fe5171edd55457d12f0e6",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- `redirect:manual`\n- `credentials:omit`"
      }
    },
    {
      "segment_id": "3f49aaf9",
      "source_content": "* Having same name headers on Android will result in only the latest one being present. A temporary solution can be found here: https://github.com/facebook/react-native/issues/18837#issuecomment-398779994.\n* Cookie based authentication is currently unstable. You can view some of the issues raised here: https://github.com/facebook/react-native/issues/23185\n* As a minimum on iOS, when redirected through a `302`, if a `Set-Cookie` header is present, the cookie is not set properly. Since the redirect cannot be handled manually this might cause a scenario where infinite requests occur if the redirect is the result of an expired session.",
      "source_content_hash": "2049b2c72c0e1cb01e0d34265ce8356fa4340b8b700aeff28029317b310a0ba9",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "* 在 Android 上使用相同名稱的標頭會導致只有最後一個被保留。臨時解決方案可參考：https://github.com/facebook/react-native/issues/18837#issuecomment-398779994。\n* 基於 cookie 的驗證目前不穩定。您可以在這裡查看部分已提出的問題：https://github.com/facebook/react-native/issues/23185。\n* 至少在 iOS 上，當透過 `302` 重新導向時，如果存在 `Set-Cookie` 標頭，cookie 不會被正確設定。由於無法手動處理重新導向，這可能導致會話過期時引發無限請求的狀況。"
      }
    },
    {
      "segment_id": "accb07e1",
      "source_content": "## Configuring NSURLSession on iOS",
      "source_content_hash": "2bda68de28eb6ee5377774f3310e901431f6efbd56e9ae85dc189d233b89f9fb",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 在 iOS 上配置 NSURLSession"
      }
    },
    {
      "segment_id": "65be34cb",
      "source_content": "For some applications it may be appropriate to provide a custom `NSURLSessionConfiguration` for the underlying `NSURLSession` that is used for network requests in a React Native application running on iOS. For instance, one may need to set a custom user agent string for all network requests coming from the app or supply `NSURLSession` with an ephemeral `NSURLSessionConfiguration`. The function `RCTSetCustomNSURLSessionConfigurationProvider` allows for such customization. Remember to add the following import to the file in which `RCTSetCustomNSURLSessionConfigurationProvider` will be called:",
      "source_content_hash": "81a13f8862a5d7c09ce61b4acda6c3a1caa3df2351f5e2481de79202744b594b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "對於某些應用程式，為 React Native 應用程式在 iOS 上執行網路請求時使用的底層 `NSURLSession` 提供自訂的 `NSURLSessionConfiguration` 可能是合適的。例如，可能需要為應用程式的所有網路請求設定自訂的使用者代理字串，或為 `NSURLSession` 提供暫時性的 `NSURLSessionConfiguration`。函數 `RCTSetCustomNSURLSessionConfigurationProvider` 允許進行此類自訂。請記得在呼叫 `RCTSetCustomNSURLSessionConfigurationProvider` 的檔案中加入以下導入："
      }
    },
    {
      "segment_id": "f4341a93",
      "source_content": "```objectivec\n#import <React/RCTHTTPRequestHandler.h>\n```",
      "source_content_hash": "485ecac0d8b2b48bdcfde5e143ad12a5db041d9065892725c8f924305df8365c",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f4341a93"
      }
    },
    {
      "segment_id": "15d5abf0",
      "source_content": "`RCTSetCustomNSURLSessionConfigurationProvider` should be called early in the application life cycle such that it is readily available when needed by React, for instance:",
      "source_content_hash": "21d257fbc2ace110e034ec07078ac855bd1792fef1a187dd64a1df0157416ea1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "`RCTSetCustomNSURLSessionConfigurationProvider` 應在應用程式生命週期的早期呼叫，以便在 React 需要時隨時可用，例如："
      }
    },
    {
      "segment_id": "5ce70a8c",
      "source_content": "```objectivec\n-(void)application:(__unused UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\n  // set RCTSetCustomNSURLSessionConfigurationProvider\n  RCTSetCustomNSURLSessionConfigurationProvider(^NSURLSessionConfiguration *{\n     NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n     // configure the session\n     return configuration;\n  });\n\n  // set up React\n  _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];\n}\n```",
      "source_content_hash": "48e518786afe02b67c7bee961a0296d2aaab47095d6c2911bf1f0c6736fe2728",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_5ce70a8c"
      }
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-docs/version-0.73/network.md",
  "last_updated_timestamp": "2025-06-18T10:03:59.396481+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "90b5aaf52137379ff5a2c180295dd8f50a4eb679643efcac7a3e66454f9296a5"
  }
}