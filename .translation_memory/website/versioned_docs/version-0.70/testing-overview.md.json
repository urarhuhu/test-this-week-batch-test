{
  "source_file_path_relative_to_docusaurus_root": "versioned_docs/version-0.70/testing-overview.md",
  "source_file_content_hash": "d58bb94b6198579438f113c91bce780bce04647597e9b2f71f6bd0f4e74212a7",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\nid: testing-overview\ntitle: Testing\nauthor: Vojtech Novak\nauthorURL: 'https://twitter.com/vonovak'\ndescription: This guide introduces React Native developers to the key concepts behind testing, how to write good tests, and what kinds of tests you can incorporate into your workflow.\n---",
      "source_content_hash": "cc3bc2f94a2720f30ee8401600c5d977f53e8586abe234c83981cde61ac5cefc",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_58cfcc64"
      }
    },
    {
      "segment_id": "53eaf0e1",
      "source_content": "As your codebase expands, small errors and edge cases you don’t expect can cascade into larger failures. Bugs lead to bad user experience and ultimately, business losses. One way to prevent fragile programming is to test your code before releasing it into the wild.",
      "source_content_hash": "82f9ed96b6c3cea64a954435481331858938f94d01eb2c09264e891b9f99bad7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "隨著程式碼庫的擴展，未預期的小錯誤和邊緣案例可能引發連鎖反應，導致更嚴重的故障。程式錯誤會造成糟糕的使用者體驗，最終導致業務損失。預防脆弱程式設計的方法之一，就是在將程式碼發布前進行測試。"
      }
    },
    {
      "segment_id": "8ac585fb",
      "source_content": "In this guide, we will cover different, automated ways to ensure your app works as expected, ranging from static analysis to end-to-end tests.",
      "source_content_hash": "7fa116b8718fc97063881e920a7c20a7842401955ddf2fe289beb6dc305bfb12",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "本指南將涵蓋多種自動化測試方法，從靜態分析到端對端測試，確保您的應用程式如預期般運作。"
      }
    },
    {
      "segment_id": "5da3670c",
      "source_content": "<img src=\"/docs/assets/diagram_testing.svg\" alt=\"Testing is a cycle of fixing, testing, and either passing to release or failing back into testing.\" />",
      "source_content_hash": "7f52efe9178444e08dcaaf47bd572646c4540173430bc45ee5990189da13299a",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_5da3670c"
      }
    },
    {
      "segment_id": "e14c9928",
      "source_content": "## Why Test",
      "source_content_hash": "3dfec73a75f92e1c419a6854410706507474b213e3c5f33945f7d2f06753e960",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 為什麼要測試"
      }
    },
    {
      "segment_id": "42ad8e83",
      "source_content": "We're humans, and humans make mistakes. Testing is important because it helps you uncover these mistakes and verifies that your code is working. Perhaps even more importantly, testing ensures that your code continues to work in the future as you add new features, refactor the existing ones, or upgrade major dependencies of your project.",
      "source_content_hash": "70a5990ab9aa67910f90a2f022928fc01330bf7c36a2fa336c866599f5fe7c15",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "人非聖賢，孰能無過。測試之所以重要，是因為它能幫助您發現這些錯誤並驗證程式碼是否正常運作。更重要的是，測試能確保在您新增功能、重構現有程式碼或升級專案主要依賴套件時，程式碼仍能持續運作。"
      }
    },
    {
      "segment_id": "f6168993",
      "source_content": "There is more value in testing than you might realize. One of the best ways to fix a bug in your code is to write a failing test that exposes it. Then when you fix the bug and re-run the test, if it passes it means the bug is fixed, never reintroduced into the code base.",
      "source_content_hash": "fc77c811b10dc50d9055c3fcec0e56e037f4de8a284d3dc510a7e2e742c2ee49",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "測試的價值遠超您的想像。修復程式錯誤的最佳方法之一，就是撰寫一個能暴露該錯誤的失敗測試。當您修復錯誤後重新執行測試，若測試通過，代表錯誤已被修復且不會再次出現在程式碼庫中。"
      }
    },
    {
      "segment_id": "f5f6d2ce",
      "source_content": "Tests can also serve as documentation for new people joining your team. For people who have never seen a codebase before, reading tests can help them understand how the existing code works.",
      "source_content_hash": "c430f463947bc053f3cab21e8f852538551f2b5b987cc7eac85ed638a07eabdd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "測試也能作為新團隊成員的技術文件。對於初次接觸程式碼庫的人來說，閱讀測試能幫助他們理解現有程式碼的運作方式。"
      }
    },
    {
      "segment_id": "2fdadb08",
      "source_content": "Last but not least, more automated testing means less time spent with manual <abbr title=\"Quality Assurance\">QA</abbr>, freeing up valuable time.",
      "source_content_hash": "4478a0db75a6b9a5005b8403c30ae471c30ec9e886006117f46615dec8fc7c49",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "最後但同樣重要的是，更多自動化測試意味著減少手動<abbr title=\"Quality Assurance\">QA</abbr>的時間，釋放寶貴資源。"
      }
    },
    {
      "segment_id": "ed7dde9c",
      "source_content": "## Static Analysis",
      "source_content_hash": "727c0ddccd08c7d52ee952389cdddb1e303f06197d209fc933176927b3530537",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 靜態分析"
      }
    },
    {
      "segment_id": "a76548f8",
      "source_content": "The first step to improve your code quality is to start using static analysis tools. Static analysis checks your code for errors as you write it, but without running any of that code.",
      "source_content_hash": "70f6416e0de53d4c76b0f44d52dce53886825d283ae88c45d4fd55b7edcb65e5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "提升程式碼品質的第一步是使用靜態分析工具。靜態分析會在您撰寫程式碼時檢查錯誤，但不會實際執行這些程式碼。"
      }
    },
    {
      "segment_id": "77bf3ec9",
      "source_content": "- **Linters** analyze code to catch common errors such as unused code and to help avoid pitfalls, to flag style guide no-nos like using tabs instead of spaces (or vice versa, depending on your configuration).\n- **Type checking** ensures that the construct you’re passing to a function matches what the function was designed to accept, preventing passing a string to a counting function that expects a number, for instance.",
      "source_content_hash": "3a57515583c7c6f1b875323d990929800df7e8bf5f1d1d59ad0b5d3816ce101c",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- **Linters** 會分析程式碼以捕捉常見錯誤（如未使用的程式碼），幫助避免陷阱，並標記違反風格指南的行為（例如使用製表符而非空格，或反之，取決於您的配置）。\n- **型別檢查** 確保傳遞給函式的參數符合函式設計預期，例如防止將字串傳遞給預期接收數字的計數函式。"
      }
    },
    {
      "segment_id": "73ab96a3",
      "source_content": "React Native comes with two such tools configured out of the box: [ESLint](https://eslint.org/) for linting and [Flow](https://flow.org/en/docs/) for type checking. You can also use [TypeScript](typescript), which is a typed language that compiles to plain JavaScript.",
      "source_content_hash": "2ccf2e44fd20e2a80bbe4cd744e9cd06331299907d798674ec1fddf546c0a07b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "React Native 預設配置了兩種工具：[ESLint](https://eslint.org/) 用於程式碼檢查，[Flow](https://flow.org/en/docs/) 用於型別檢查。您也可以使用 [TypeScript](typescript)，這是一種會編譯成純 JavaScript 的型別化語言。"
      }
    },
    {
      "segment_id": "a1b3d8cb",
      "source_content": "## Writing Testable Code",
      "source_content_hash": "67c943ce6086ff1504ce6e8b2c9e8a97ac08da9eaf2fac57f3b01b86ad84fd82",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 撰寫可測試的程式碼"
      }
    },
    {
      "segment_id": "517051a7",
      "source_content": "To start with tests, you first need to write code that is testable. Consider an aircraft manufacturing process - before any model first takes off to show that all of its complex systems work well together, individual parts are tested to guarantee they are safe and function correctly. For example, wings are tested by bending them under extreme load; engine parts are tested for their durability; the windshield is tested against simulated bird impact.",
      "source_content_hash": "22082264dda4709cd4c1f31651d331679ba71a0ff86df4ea9dc7dda21d740581",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "要開始測試，首先需要撰寫可測試的程式碼。以飛機製造過程為例——在模型首次起飛展示所有複雜系統協同運作前，會先測試各個零件以確保其安全性和功能性。例如：機翼需承受極端負載彎曲測試、引擎零件需通過耐久性測試、擋風玻璃需模擬鳥擊測試。"
      }
    },
    {
      "segment_id": "135468ee",
      "source_content": "Software is similar. Instead of writing your entire program in one huge file with many lines of code, you write your code in multiple small modules that you can test more thoroughly than if you tested the assembled whole. In this way, writing testable code is intertwined with writing clean, modular code.",
      "source_content_hash": "f4b0fd62b76e2734610011d5beb8279b4742cdb7ef27e70d842c6980ded5dfbb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "軟體開發亦是如此。與其將整個程式寫在一個龐大檔案中，不如將程式碼拆分為多個小型模組，這樣能比測試組裝後的整體進行更徹底的測試。因此，撰寫可測試程式碼與撰寫乾淨、模組化的程式碼息息相關。"
      }
    },
    {
      "segment_id": "33331f27",
      "source_content": "To make your app more testable, start by separating the view part of your app—your React components—from your business logic and app state (regardless of whether you use Redux, MobX or other solutions). This way, you can keep your business logic testing—which shouldn’t rely on your React components—independent of the components themselves, whose job is primarily rendering your app’s UI!",
      "source_content_hash": "79ee9e2f93bdadc6a918d66bbef9dc7448674f54075c3cdfeb3e5871f1f8b267",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "要讓應用程式更具可測試性，首先需將視圖部分（React 元件）與業務邏輯和應用狀態分離（無論您使用 Redux、MobX 或其他解決方案）。如此一來，您就能讓業務邏輯測試（不應依賴 React 元件）獨立於元件本身，而元件的主要職責是渲染應用程式的 UI！"
      }
    },
    {
      "segment_id": "50746522",
      "source_content": "Theoretically, you could go so far as to move all logic and data fetching out of your components. This way your components would be solely dedicated to rendering. Your state would be entirely independent of your components. Your app’s logic would work without any React components at all!",
      "source_content_hash": "685c71165a7e90d6c18b355e55b4969f95120447908bb8c45def62a3d01c4710",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "理論上，您甚至可以將所有邏輯和資料獲取移出元件，讓元件專注於渲染。應用狀態將完全獨立於元件，業務邏輯能在完全沒有 React 元件的情況下運作！"
      }
    },
    {
      "segment_id": "da4202dd",
      "source_content": "> We encourage you to further explore the topic of testable code in other learning resources.",
      "source_content_hash": "1e6ae5fb540adaab926cb8ab35961b6c022bc46e86b237a34500ca6522b4d0ba",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> 我們鼓勵您透過其他學習資源進一步探索可測試程式碼的主題。"
      }
    },
    {
      "segment_id": "8bddee80",
      "source_content": "## Writing Tests",
      "source_content_hash": "ab7d14351258511ffb73b5e0cbbd81aca079d6613aa7548f46beedc71d7a15ba",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 撰寫測試"
      }
    },
    {
      "segment_id": "a9d49f92",
      "source_content": "After writing testable code, it’s time to write some actual tests! The default template of React Native ships with [Jest](https://jestjs.io) testing framework. It includes a preset that's tailored to this environment so you can get productive without tweaking the configuration and mocks straight away—[more on mocks](#mocking) shortly. You can use Jest to write all types of tests featured in this guide.",
      "source_content_hash": "f05eab90ef83d25eea07d2efbdf706bee6f97463699c7a4cf2b52331de6a7bd2",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b50c461f",
      "source_content": "> If you do test-driven development, you actually write tests first! That way, testability of your code is given.",
      "source_content_hash": "a3aa44cca04bfdddafa60d8ab9fdae7788b9cc79843838f75a041fdfc450dca6",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "cb5b269c",
      "source_content": "### Structuring Tests",
      "source_content_hash": "52e20b82848542a8e186abd2ff542494c4d116bd9e7513d2c446141d9aa58f55",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b36c6338",
      "source_content": "Your tests should be short and ideally test only one thing. Let's start with an example unit test written with Jest:",
      "source_content_hash": "ca911fedbff5397474db7a6021aafb14be0a41249902383902ec07d163616870",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "eb80afe1",
      "source_content": "```js\nit('given a date in the past, colorForDueDate() returns red', () => {\n  expect(colorForDueDate('2000-10-20')).toBe('red');\n});\n```",
      "source_content_hash": "ca7cf1c458b3b2030d41c0ed10d4be43cf12e13498235b4bc7f6a4eb24d8bf1c",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "6ea4c715",
      "source_content": "The test is described by the string passed to the [`it`](https://jestjs.io/docs/en/api#testname-fn-timeout) function. Take good care writing the description so that it’s clear what is being tested. Do your best to cover the following:",
      "source_content_hash": "1b7a2b931ea329fd04365e8ea9a6aade67e2a0caa1f41bde9ec1dcdc6cd33cb4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "158e1f5d",
      "source_content": "1. **Given** - some precondition\n2. **When** - some action executed by the function that you’re testing\n3. **Then** - the expected outcome",
      "source_content_hash": "8d5922958503a968b2ca1371e35b952be528e8a79a1575513f8a403440602380",
      "node_type": "list",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "06e24cc0",
      "source_content": "This is also known as AAA (Arrange, Act, Assert).",
      "source_content_hash": "d8a4fbd0ee2a0969cf450676f9651873c7fa0567f838e4a10a3e4b21ceed08ad",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7f71ff2a",
      "source_content": "Jest offers [`describe`](https://jestjs.io/docs/en/api#describename-fn) function to help structure your tests. Use `describe` to group together all tests that belong to one functionality. Describes can be nested, if you need that. Other functions you'll commonly use are [`beforeEach`](https://jestjs.io/docs/en/api#beforeeachfn-timeout) or [`beforeAll`](https://jestjs.io/docs/en/api#beforeallfn-timeout) that you can use for setting up the objects you're testing. Read more in the [Jest api reference](https://jestjs.io/docs/en/api).",
      "source_content_hash": "ebaab215bfec8613b548779ebff0483e769f5be78e8400092bc45b66a813ff68",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "147e8550",
      "source_content": "If your test has many steps or many expectations, you probably want to split it into multiple smaller ones. Also, ensure that your tests are completely independent of one another. Each test in your suite must be executable on its own without first running some other test. Conversely, if you run all your tests together, the first test must not influence the output of the second one.",
      "source_content_hash": "b93b9b4369a8f88023321d565f419ebd0f4ed3f53e2c4d2a737daea1124bef11",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "883231d4",
      "source_content": "Lastly, as developers we like when our code works great and doesn't crash. With tests, this is often the opposite. Think of a failed test as of a _good thing!_ When a test fails, it often means something is not right. This gives you an opportunity to fix the problem before it impacts the users.",
      "source_content_hash": "8b257e1d6be81322d0c8e32e577e225e6d2d8740d57c678f6b01e7b012a62846",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "b051b70c",
      "source_content": "## Unit tests",
      "source_content_hash": "2311a4234224c9a5cf76847ce5e1a9e3e30528d63c26ff30f82dd9dc74962c23",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "d0dd855b",
      "source_content": "Unit tests cover the smallest parts of code, like individual functions or classes.",
      "source_content_hash": "f97ac4afadc30fd1acc4e0a73ace9b848730f22365d78aef6f6fe0f88d8acfc5",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "7736989b",
      "source_content": "When the object being tested has any dependencies, you’ll often need to mock them out, as described in the next paragraph.",
      "source_content_hash": "15331d6a8e5594f093b266714f200e3c0977afed06686523297dd3bd2365649e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "6270d577",
      "source_content": "The great thing about unit tests is that they are quick to write and run. Therefore, as you work, you get fast feedback about whether your tests are passing. Jest even has an option to continuously run tests that are related to code you’re editing: [Watch mode](https://jestjs.io/docs/en/cli#watch).",
      "source_content_hash": "7dccb9ffcbf7899f21a267ff1b5e3bbe6656b27d3c0c5b11c562f48c285cfb19",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "3e8b4b41",
      "source_content": "<img src=\"/docs/assets/p_tests-unit.svg\" alt=\" \" />",
      "source_content_hash": "bce1b7effe3bf015e5a8900eb0abdf35b0d28a61427d19d0fadde21a0683211e",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "1c598ecd",
      "source_content": "### Mocking",
      "source_content_hash": "27d5ce8b4a9183bb69846b93e044b7c67f213b539c4f6a6794462a9d0857c6e8",
      "node_type": "heading",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "2547a6bb",
      "source_content": "Sometimes, when your tested objects have external dependencies, you’ll want to “mock them out.” “Mocking” is when you replace some dependency of your code with your own implementation.",
      "source_content_hash": "99adf80f6b41977267b0944e635effcc62e34cad5ddef8bb366977ba264e88a4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "30d027a1",
      "source_content": "> Generally, using real objects in your tests is better than using mocks but there are situations where this is not possible. For example: when your JS unit test relies on a native module written in Java or Objective-C.",
      "source_content_hash": "d6c85859b772c0642b44b2496802039441c76286160e556800c841f9e5f15b4a",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "86348f98",
      "source_content": "Imagine you’re writing an app that shows the current weather in your city and you’re using some external service or other dependency that provides you with the weather information. If the service tells you that it’s raining, you want to show an image with a rainy cloud. You don’t want to call that service in your tests, because:",
      "source_content_hash": "243f1b8a585e3ce2bcf9ad3490831827d3fe499752c1ce847b72d7545569aa7d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {}
    },
    {
      "segment_id": "023197ab",
      "source_content": "- It could make the tests slow and unstable (because of the network requests involved)\n- The service may return different data every time you run the test\n- Third party services can go offline when you really need to run tests!",
      "source_content_hash": "2b509152adb781615dbe150d1e964848b367506cc30f21fbfd8d23db6d56fd5c",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 這可能導致測試變慢且不穩定（因為涉及網路請求）\n- 每次執行測試時，該服務可能返回不同的數據\n- 第三方服務可能在您急需執行測試時離線！"
      }
    },
    {
      "segment_id": "eb51d107",
      "source_content": "Therefore, you can provide a mock implementation of the service, effectively replacing thousands of lines of code and some internet-connected thermometers!",
      "source_content_hash": "bb1c7561c2f6fe9b1542535419956bd7bf87c974724e07f772ee09877ad12f6e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "因此，您可以提供該服務的模擬實現，實際上替換了數千行程式碼和某些連網的溫度計！"
      }
    },
    {
      "segment_id": "eff16de8",
      "source_content": "> Jest comes with [support for mocking](https://jestjs.io/docs/en/mock-functions#mocking-modules) from function level all the way to module level mocking.",
      "source_content_hash": "64eaf8184c9768852f868411abb7098407e0a7e6b1de8475b4bd4beaec98d221",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> Jest 內建[模擬支援](https://jestjs.io/docs/en/mock-functions#mocking-modules)，從函數級別到模組級別的模擬都能處理。"
      }
    },
    {
      "segment_id": "a138e327",
      "source_content": "## Integration Tests",
      "source_content_hash": "b70d06124533107318c3c5978f3677080e3828eed9e7bd368bdca7e83cf194cf",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 整合測試"
      }
    },
    {
      "segment_id": "a2c0166e",
      "source_content": "When writing larger software systems, individual pieces of it need to interact with each other. In unit testing, if your unit depends on another one, you’ll sometimes end up mocking the dependency, replacing it with a fake one.",
      "source_content_hash": "ba86a2d5228ac4d5027dba16b1caad94449efbaf739291353c9ca3a13185e6d7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在編寫較大的軟體系統時，其各個部分需要相互交互。在單元測試中，如果您的單元依賴於另一個單元，有時最終會模擬該依賴項，用假的替換它。"
      }
    },
    {
      "segment_id": "c1eaf30b",
      "source_content": "In integration testing, real individual units are combined (same as in your app) and tested together to ensure that their cooperation works as expected. This is not to say that mocking does not happen here: you’ll still need mocks (for example, to mock communication with a weather service), but you'll need them much less than in unit testing.",
      "source_content_hash": "1b2ede0ec28035b16b5a62036252cc3ae5227556ddcc8809ea582e43c5f2b9e6",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在整合測試中，真實的單個單元被組合（與您的應用程式相同）並一起測試，以確保它們的合作按預期工作。這並不是說這裡不會發生模擬：您仍然需要模擬（例如，模擬與天氣服務的通信），但比單元測試中需要的少得多。"
      }
    },
    {
      "segment_id": "ceb1ddd1",
      "source_content": "> Please note that the terminology around what integration testing means is not always consistent. Also, the line between what is a unit test and what is an integration test may not always be clear. For this guide, your test falls into \"integration testing\" if it:\n>\n> - Combines several modules of your app as described above\n> - Uses an external system\n> - Makes a network call to other application (such as the weather service API)\n> - Does any kind of file or database <abbr title=\"Input/Output\">I/O</abbr>",
      "source_content_hash": "834dbf46ea41948769198194bea7ce035b2d056ec8f50e332ef6343e02ceeea7",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> 請注意，關於整合測試含義的術語並不總是一致的。此外，單元測試和整合測試之間的界限可能並不總是清晰。對於本指南，如果您的測試符合以下條件，則屬於「整合測試」：\n>\n> - 如上所述，組合了應用程式的多個模組\n> - 使用外部系統\n> - 向其他應用程式（例如天氣服務API）發送網路請求\n> - 進行任何類型的檔案或數據庫<abbr title=\"輸入/輸出\">I/O</abbr>操作"
      }
    },
    {
      "segment_id": "f018dbb4",
      "source_content": "<img src=\"/docs/assets/p_tests-integration.svg\" alt=\" \" />",
      "source_content_hash": "7a6b5a8a8aa8b784d04b54f56776974af0b6a3f11697e0803e82661e0fedfeef",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "48155948",
      "source_content": "## Component Tests",
      "source_content_hash": "0b277cdeacbae3920dbdd226cfd8643ff7dac3948944bfc1133a83cd291bdc44",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 元件測試"
      }
    },
    {
      "segment_id": "1958bc43",
      "source_content": "React components are responsible for rendering your app, and users will directly interact with their output. Even if your app's business logic has high testing coverage and is correct, without component tests you may still deliver a broken UI to your users. Component tests could fall into both unit and integration testing, but because they are such a core part of React Native, we'll cover them separately.",
      "source_content_hash": "956b69d2d7391ee1234cc85b4659cbe6df10ac4cc078f7d9e2a968f794bb035a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "React 元件負責渲染您的應用程式，用戶將直接與其輸出交互。即使您的應用程式的業務邏輯測試覆蓋率高且正確，如果沒有元件測試，您仍可能向用戶交付損壞的UI。元件測試可能屬於單元和整合測試，但因為它們是 React Native 的核心部分，我們將單獨介紹。"
      }
    },
    {
      "segment_id": "a8610918",
      "source_content": "For testing React components, there are two things you may want to test:",
      "source_content_hash": "c87dfef2e15c97de3374cdc3a964c129f9305943f2b5d5fceeb1d5ddaf1d1d5c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "對於測試 React 元件，您可能需要測試兩件事："
      }
    },
    {
      "segment_id": "9673e622",
      "source_content": "- Interaction: to ensure the component behaves correctly when interacted with by a user (eg. when user presses a button)\n- Rendering: to ensure the component render output used by React is correct (eg. the button's appearance and placement in the UI)",
      "source_content_hash": "d784750b615d21f372c6928c7b45a03ac7b3df597888e3012fa632c333cc495b",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 交互：確保元件在用戶交互時行為正確（例如，當用戶按下按鈕時）\n- 渲染：確保 React 使用的元件渲染輸出正確（例如，按鈕的外觀和在UI中的位置）"
      }
    },
    {
      "segment_id": "5f82a1e9",
      "source_content": "For example, if you have a button that has an `onPress` listener, you want to test that the button both appears correctly and that tapping the button is correctly handled by the component.",
      "source_content_hash": "086e898e31ce1b2e640910bfd6771b1ba997cc054160c07c9da174f7fb5c1890",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "例如，如果您有一個帶有 `onPress` 監聽器的按鈕，您希望測試按鈕是否正確顯示以及點擊按鈕是否被元件正確處理。"
      }
    },
    {
      "segment_id": "6fc234cf",
      "source_content": "There are several libraries that can help you testing these:",
      "source_content_hash": "1668d6ddd26bef5ded51cf74383226e29e0f36ac483093f87de9dcb96518336b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "有幾個庫可以幫助您測試這些："
      }
    },
    {
      "segment_id": "d9b1e67e",
      "source_content": "- React’s [Test Renderer](https://reactjs.org/docs/test-renderer.html), developed alongside its core, provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.\n- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) builds on top of React’s test renderer and adds `fireEvent` and `query` APIs described in the next paragraph.",
      "source_content_hash": "01ba793a1cf1e26a8f4f412bc05db7d9277d0727031e18e3b00d9a77b73b57fa",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- React 的[測試渲染器](https://reactjs.org/docs/test-renderer.html)，與其核心一起開發，提供了一個 React 渲染器，可用於將 React 元件渲染為純 JavaScript 對象，而不依賴於 DOM 或原生移動環境。\n- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) 建立在 React 的測試渲染器之上，並添加了下一段中描述的 `fireEvent` 和 `query` API。"
      }
    },
    {
      "segment_id": "919de16a",
      "source_content": "> Component tests are only JavaScript tests running in Node.js environment. They do _not_ take into account any iOS, Android, or other platform code which is backing the React Native components. It follows that they cannot give you a 100% confidence that everything works for the user. If there is a bug in the iOS or Android code, they will not find it.",
      "source_content_hash": "2d30ffbaabd09ad76a37fb4549d816de9baa620ed78ac92d5fec1ea962e5092b",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> 元件測試僅是在 Node.js 環境中運行的 JavaScript 測試。它們不考慮任何 iOS、Android 或其他支持 React Native 元件的平台代碼。因此，它們無法給您100%的信心，確保一切對用戶都正常運作。如果 iOS 或 Android 代碼中存在錯誤，它們將無法發現。"
      }
    },
    {
      "segment_id": "448a0039",
      "source_content": "<img src=\"/docs/assets/p_tests-component.svg\" alt=\" \" />",
      "source_content_hash": "219b7eefc0a04076c95e4724b4a89b69224b16a89c52d22b6b76d5f75de20423",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "a461a67b",
      "source_content": "### Testing User Interactions",
      "source_content_hash": "0804bc91bef03bbcaecbf4c7f9ddd71837a09f47cd17dd9a967076f15ac30e95",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 測試用戶交互"
      }
    },
    {
      "segment_id": "e77cf7c6",
      "source_content": "Aside from rendering some UI, your components handle events like `onChangeText` for `TextInput` or `onPress` for `Button`. They may also contain other functions and event callbacks. Consider the following example:",
      "source_content_hash": "63fbcbff9de9427d4bdc8e1cc553df2b750d896df31421e80bc2acbbc1f877fd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "除了渲染某些UI外，您的元件還處理事件，如 `TextInput` 的 `onChangeText` 或 `Button` 的 `onPress`。它們可能還包含其他函數和事件回調。考慮以下示例："
      }
    },
    {
      "segment_id": "6e57b94c",
      "source_content": "```jsx\nfunction GroceryShoppingList() {\n  const [groceryItem, setGroceryItem] = useState('');\n  const [items, setItems] = useState([]);\n\n  const addNewItemToShoppingList = useCallback(() => {\n    setItems([groceryItem, ...items]);\n    setGroceryItem('');\n  }, [groceryItem, items]);\n\n  return (\n    <>\n      <TextInput\n        value={groceryItem}\n        placeholder=\"Enter grocery item\"\n        onChangeText={text => setGroceryItem(text)}\n      />\n      <Button\n        title=\"Add the item to list\"\n        onPress={addNewItemToShoppingList}\n      />\n      {items.map(item => (\n        <Text key={item}>{item}</Text>\n      ))}\n    </>\n  );\n}\n```",
      "source_content_hash": "19a7c4aaf382f3defc246e6d44685d488ee77dd52573aa69103710a36541700f",
      "node_type": "code",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "b08ad0b4",
      "source_content": "When testing user interactions, test the component from the user perspective—what's on the page? What changes when interacted with?",
      "source_content_hash": "8b8bb2bc3aeb9c56dfa08f9106cf4d5029fbf68f5aa9dbbd1c949fa9e33e6412",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在測試用戶交互時，從用戶的角度測試元件——頁面上有什麼？交互時會發生什麼變化？"
      }
    },
    {
      "segment_id": "d636abf8",
      "source_content": "As a rule of thumb, prefer using things users can see or hear:",
      "source_content_hash": "82e521b4ed3e0b7981d3859cbb165f20eefc31f9871af3c2db3f85c6dad53a8e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "作為經驗法則，優先使用用戶可以看到或聽到的內容："
      }
    },
    {
      "segment_id": "e1b58cbf",
      "source_content": "- make assertions using rendered text or [accessibility helpers](https://reactnative.dev/docs/accessibility#accessibility-properties)",
      "source_content_hash": "eb02302232e80863c48ed79ce9fd580ee3ac68c7c7e7c1f2064353e9581ac8a3",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 使用渲染的文字或[無障礙輔助功能工具](https://reactnative.dev/docs/accessibility#accessibility-properties)進行斷言"
      }
    },
    {
      "segment_id": "85ea22dd",
      "source_content": "Conversely, you should avoid:",
      "source_content_hash": "774502ccda2e4d6e8365b69d07125ffbe5d701548631a06a087b95fdb128e34f",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "相反地，你應該避免："
      }
    },
    {
      "segment_id": "db79148c",
      "source_content": "- making assertions on component props or state\n- testID queries",
      "source_content_hash": "29d81997c1b934a71402373c87893c1021f912c87b581d6227d7a45870e884a0",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 對元件的 props 或 state 進行斷言\n- 使用 testID 查詢"
      }
    },
    {
      "segment_id": "39c48ff7",
      "source_content": "Avoid testing implementation details like props or state—while such tests work, they are not oriented toward how users will interact with the component and tend to break by refactoring (for example when you'd like to rename some things or rewrite class component using hooks).",
      "source_content_hash": "ab35d8f21120fe753efb14c46179134e43aee571044124f557ff697171e4bc8b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "避免測試實作細節如 props 或 state——雖然這類測試可行，但它們並非以使用者與元件互動的方式為導向，且容易因重構而失效（例如當你想重新命名某些東西或用 hooks 改寫類別元件時）。"
      }
    },
    {
      "segment_id": "001e6f78",
      "source_content": "> React class components are especially prone to testing their implementation details such as internal state, props or event handlers. To avoid testing implementation details, prefer using function components with Hooks, which make relying on component internals _harder_.",
      "source_content_hash": "994162dbbcc401fcb613a41b1754715b0fad2f42610a8737ccdd60829db9e2d3",
      "node_type": "blockquote",
      "translatable": true,
      "translations": {
        "zh-hant": "> React 類別元件尤其容易測試其實作細節，如內部狀態、props 或事件處理器。為避免測試實作細節，建議優先使用帶有 Hooks 的函式元件，這會讓依賴元件內部細節變得更加困難。"
      }
    },
    {
      "segment_id": "e5821418",
      "source_content": "Component testing libraries such as [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) facilitate writing user-centric tests by careful choice of provided APIs. The following example uses `fireEvent` methods `changeText` and `press` that simulate a user interacting with the component and a query function `getAllByText` that finds matching `Text` nodes in the rendered output.",
      "source_content_hash": "2d53355752c1d754a2ba1c67c6a6662a11cb9c2eaffb4a109428f0295c7e272b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "像 [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) 這樣的元件測試函式庫，透過精心選擇提供的 API，有助於撰寫以使用者為中心的測試。以下範例使用 `fireEvent` 方法 `changeText` 和 `press` 來模擬使用者與元件的互動，以及查詢函式 `getAllByText` 來找出渲染輸出中匹配的 `Text` 節點。"
      }
    },
    {
      "segment_id": "1cd1d315",
      "source_content": "```jsx\ntest('given empty GroceryShoppingList, user can add an item to it', () => {\n  const {getByPlaceholder, getByText, getAllByText} = render(\n    <GroceryShoppingList />,\n  );\n\n  fireEvent.changeText(\n    getByPlaceholder('Enter grocery item'),\n    'banana',\n  );\n  fireEvent.press(getByText('Add the item to list'));\n\n  const bananaElements = getAllByText('banana');\n  expect(bananaElements).toHaveLength(1); // expect 'banana' to be on the list\n});\n```",
      "source_content_hash": "f7a4cfc3cd96964b12858ad5f107184a744a41c0ccaa5a3907377f2b73be1362",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_1cd1d315"
      }
    },
    {
      "segment_id": "48249e3c",
      "source_content": "This example is not testing how some state changes when you call a function. It tests what happens when a user changes text in the `TextInput` and presses the `Button`!",
      "source_content_hash": "ae12b577d3700fe48b244311404e191e81b1a76f9d33e829846dba2432673ca9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "這個範例並非測試當你呼叫某個函式時狀態如何變化。它測試的是當使用者在 `TextInput` 中變更文字並按下 `Button` 時會發生什麼！"
      }
    },
    {
      "segment_id": "a7628008",
      "source_content": "### Testing Rendered Output",
      "source_content_hash": "ca506cebb531e54daffb77226641d3d965d71b84e925a5b3a9d096a944e6aa0b",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 測試渲染輸出"
      }
    },
    {
      "segment_id": "7e563909",
      "source_content": "[Snapshot testing](https://jestjs.io/docs/en/snapshot-testing) is an advanced kind of testing enabled by Jest. It is a very powerful and low-level tool, so extra attention is advised when using it.",
      "source_content_hash": "75fa41b9a1dc8ec702c662512c45ec0ec8dbe7e61151cdad10e2fe7e240cb00d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "[快照測試](https://jestjs.io/docs/en/snapshot-testing)是 Jest 提供的一種進階測試方式。它是一個非常強大且底層的工具，因此使用時需格外謹慎。"
      }
    },
    {
      "segment_id": "90c4b96b",
      "source_content": "A \"component snapshot\" is a JSX-like string created by a custom React serializer built into Jest. This serializer lets Jest translate React component trees to string that's human-readable. Put another way: a component snapshot is a textual representation of your component’s render output _generated_ during a test run. It may look like this:",
      "source_content_hash": "66ea2db3798feb057cce2e67c0887c780d2bf85eaba5518ae046555641d4d397",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "「元件快照」是由 Jest 內建的自訂 React 序列化器所產生的 JSX 風格字串。這個序列化器讓 Jest 能將 React 元件樹轉換為人類可讀的字串。換句話說：元件快照是你的元件在測試執行期間所產生之渲染輸出的文字表示。它可能看起來像這樣："
      }
    },
    {
      "segment_id": "f377fafa",
      "source_content": "```jsx\n<Text\n  style={\n    Object {\n      \"fontSize\": 20,\n      \"textAlign\": \"center\",\n    }\n  }>\n  Welcome to React Native!\n</Text>\n```",
      "source_content_hash": "07059535c7d18a02f763c7779b235b2db47fb13ee794e33fb3a24c814fcc0f9d",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_f377fafa"
      }
    },
    {
      "segment_id": "f6479c91",
      "source_content": "With snapshot testing, you typically first implement your component and then run the snapshot test. The snapshot test then creates a snapshot and saves it to a file in your repo as a reference snapshot. **The file is then committed and checked during code review**. Any future changes to the component render output will change its snapshot, which will cause the test to fail. You then need to update the stored reference snapshot for the test to pass. That change again needs to be committed and reviewed.",
      "source_content_hash": "bf4e131742d2e2d7650f397292920fb7e00303526e4b0702835ab0be346e3a3e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "進行快照測試時，通常你會先實作你的元件，然後執行快照測試。快照測試接著會建立一個快照，並將其作為參考快照儲存到你的代碼庫中的一個檔案裡。**該檔案會被提交並在代碼審查時檢查**。未來對元件渲染輸出的任何變更都會改變其快照，導致測試失敗。此時你需要更新儲存的參考快照才能使測試通過。該變更同樣需要被提交和審查。"
      }
    },
    {
      "segment_id": "61e5dad6",
      "source_content": "Snapshots have several weak points:",
      "source_content_hash": "385f683f8027655ff87a9f354ec8fc39c8cc7e0416543ddcefec65b85ac98e25",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "快照有幾個弱點："
      }
    },
    {
      "segment_id": "1537994d",
      "source_content": "- For you as a developer or reviewer, it can be hard to tell whether a change in snapshot is intended or whether it's evidence of a bug. Especially large snapshots can quickly become hard to understand and their added value becomes low.\n- When snapshot is created, at that point it is considered to be correct-even in the case when the rendered output is actually wrong.\n- When a snapshot fails, it's tempting to update it using the `--updateSnapshot` jest option without taking proper care to investigate whether the change is expected. Certain developer discipline is thus needed.",
      "source_content_hash": "6e86a2d32ddbb217324595209ac93348caf2a3c9062a7f836b6eb66d34c350ca",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 對開發者或審查者而言，可能難以判斷快照中的變更是有意為之還是錯誤的證據。特別是大型快照可能很快變得難以理解，其附加價值也會降低。\n- 當快照被建立時，它在那個時間點被視為正確的——即使渲染輸出實際上可能是錯誤的。\n- 當快照失敗時，開發者容易不經仔細檢查變更是否預期，就直接使用 `--updateSnapshot` jest 選項更新快照。因此需要一定的開發紀律。"
      }
    },
    {
      "segment_id": "228d01d5",
      "source_content": "Snapshots themselves do not ensure that your component render logic is correct, they are merely good at guarding against unexpected changes and for checking that the components in the React tree under test receive the expected props (styles and etc.).",
      "source_content_hash": "a51b051f8f55b6e44629946ab3e9d47ec0f9a2c1829cc411a2f78537dd90031c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "快照本身並不能確保你的元件渲染邏輯正確，它們主要擅長防範意外變更，以及檢查測試中的 React 樹下的元件是否接收到預期的 props（樣式等）。"
      }
    },
    {
      "segment_id": "85b17c36",
      "source_content": "We recommend that you only use small snapshots (see [`no-large-snapshots` rule](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md)). If you want to test a _change_ between two React component states, use [`snapshot-diff`](https://github.com/jest-community/snapshot-diff). When in doubt, prefer explicit expectations as described in the previous paragraph.",
      "source_content_hash": "6c6f62181079f3cacc162fda7adee491cd6e44c44c8a2764e72b46e246fbdc76",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "我們建議你只使用小型快照（參見 [`no-large-snapshots` 規則](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md)）。如果你想測試兩個 React 元件狀態之間的變更，可以使用 [`snapshot-diff`](https://github.com/jest-community/snapshot-diff)。如有疑問，優先選擇如前一節所述的明確期望值。"
      }
    },
    {
      "segment_id": "de60fdf8",
      "source_content": "<img src=\"/docs/assets/p_tests-snapshot.svg\" alt=\" \" />",
      "source_content_hash": "45fbc00d864efe777fc29c8f55231405abeb67071204440011e3adc696115b82",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-hant": "@@untranslatable_placeholder_de60fdf8"
      }
    },
    {
      "segment_id": "67dfd717",
      "source_content": "## End-to-End Tests",
      "source_content_hash": "051640ef12f2cc94ec779acacdb0fdfb808b87202983ea640c4d19fc56ed8ea5",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 端對端測試"
      }
    },
    {
      "segment_id": "ba12acea",
      "source_content": "In end-to-end (E2E) tests, you verify your app is working as expected on a device (or a simulator / emulator) from the user perspective.",
      "source_content_hash": "4ce65cb4a732cc3255b8c2dd57d9d9f94416318e64fa6c3a270b35c6792b324d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "在端對端（E2E）測試中，你從使用者的角度驗證你的應用程式在裝置（或模擬器/仿真器）上是否如預期運作。"
      }
    },
    {
      "segment_id": "4033c370",
      "source_content": "This is done by building your app in the release configuration and running the tests against it. In E2E tests, you no longer think about React components, React Native APIs, Redux stores or any business logic. That is not the purpose of E2E tests and those are not even accessible to you during E2E testing.",
      "source_content_hash": "d51fef27b5bb5436a009a4d483fc5755c21e75220746e83402d75dbf3f9fce5d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "這需要將你的應用程式建置為發布版本，並針對該版本運行測試。在端對端測試中，你不再需要考慮 React 元件、React Native API、Redux 儲存或任何業務邏輯。這些並非端對端測試的目的，且在端對端測試過程中甚至無法存取這些內容。"
      }
    },
    {
      "segment_id": "dfb6fc67",
      "source_content": "Instead, E2E testing libraries allow you to find and control elements in the screen of your app: for example, you can _actually_ tap buttons or insert text into `TextInputs` the same way a real user would. Then you can make assertions about whether or not a certain element exists in the app’s screen, whether or not it’s visible, what text it contains, and so on.",
      "source_content_hash": "654855652068b470817f8899947423c76d4fe07f213360a795ed2aacfa0e363c",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "相反地，端對端測試函式庫讓你能夠在應用程式畫面中尋找並控制元素：例如，你可以像真實用戶一樣實際點擊按鈕或在 `TextInput` 中輸入文字。接著，你可以斷言某個元素是否存在於應用程式畫面中、是否可見、包含什麼文字等等。"
      }
    },
    {
      "segment_id": "80dbdeb8",
      "source_content": "E2E tests give you the highest possible confidence that part of your app is working. The tradeoffs include:",
      "source_content_hash": "f0c7367d2cddedbd293bef463016a5a602c851f966e93522e1acc23257404acb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "端對端測試能為你提供應用程式某部分正常運作的最大信心。其代價包括："
      }
    },
    {
      "segment_id": "13f5db84",
      "source_content": "- writing them is more time consuming compared to the other types of tests\n- they are slower to run\n- they are more prone to flakiness (a \"flaky\" test is a test which randomly passes and fails without any change to code)",
      "source_content_hash": "ab61e21123fba26ddc915c989db3cfd1425ea94e69fa4e52aabbd579935ed620",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- 撰寫這些測試比其他類型的測試更耗時\n- 執行速度較慢\n- 更容易出現不穩定性（「不穩定」測試是指隨機通過或失敗，而程式碼沒有任何變更的測試）"
      }
    },
    {
      "segment_id": "b0c30ab4",
      "source_content": "Try to cover the vital parts of your app with E2E tests: authentication flow, core functionalities, payments, etc. Use faster JS tests for the non-vital parts of your app. The more tests you add, the higher your confidence, but also, the more time you'll spend maintaining and running them. Consider the tradeoffs and decide what's best for you.",
      "source_content_hash": "81ae0a3239cbfa174eb40623a7ebc6246825879e68b8b9d379d1d0e3513653c9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "嘗試用端對端測試覆蓋應用程式的關鍵部分：身份驗證流程、核心功能、支付等。對於非關鍵部分，使用更快的 JavaScript 測試。你添加的測試越多，信心就越高，但維護和執行它們的時間也會越多。請權衡利弊，決定什麼最適合你。"
      }
    },
    {
      "segment_id": "318fb07e",
      "source_content": "There are several E2E testing tools available: in the React Native community, [Detox](https://github.com/wix/detox/) is a popular framework because it’s tailored for React Native apps. Another popular library in the space of iOS and Android apps is [Appium](http://appium.io/).",
      "source_content_hash": "ec32c9ebbe6ddd848bc1963a3e8275bf3bb6953684c4f96300d58fe0d651a993",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "有幾種可用的端對端測試工具：在 React Native 社群中，[Detox](https://github.com/wix/detox/) 是一個流行的框架，因為它是專為 React Native 應用程式設計的。另一個在 iOS 和 Android 應用程式領域流行的函式庫是 [Appium](http://appium.io/)。"
      }
    },
    {
      "segment_id": "e698fc81",
      "source_content": "<img src=\"/docs/assets/p_tests-e2e.svg\" alt=\" \" />",
      "source_content_hash": "45254901ab1ff842b02c6ef88973cb6af38c8c46cbe9f858c41df571d584aa4f",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {}
    },
    {
      "segment_id": "50e53dff",
      "source_content": "## Summary",
      "source_content_hash": "30ac03ff33731529441be8fbe52a3bd0d4c5ec830e806d54692168ebb7f98ada",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "## 總結"
      }
    },
    {
      "segment_id": "f6e7e6a7",
      "source_content": "We hope you enjoyed reading and learned something from this guide. There are many ways you can test your apps. It may be hard to decide what to use at first. However, we believe it all will make sense once you start adding tests to your awesome React Native app. So what are you waiting for? Get your coverage up!",
      "source_content_hash": "0be3ea3a1827aee3473e024b39e88542d01a8b6cddd3ef5397d053e31c40f383",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "我們希望你在閱讀本指南時有所收穫。測試應用程式的方法有很多種，一開始可能很難決定使用什麼。然而，我們相信一旦你開始為出色的 React Native 應用程式添加測試，一切都會變得清晰。那麼還在等什麼？提高你的測試覆蓋率吧！"
      }
    },
    {
      "segment_id": "99e592b0",
      "source_content": "### Links",
      "source_content_hash": "952dce07a1bc56487bf4800dcd92fd9705b2b44016bf7045c7a953ea28ea7067",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-hant": "### 相關連結"
      }
    },
    {
      "segment_id": "dae0c632",
      "source_content": "- [React testing overview](https://reactjs.org/docs/testing.html)\n- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)\n- [Jest docs](https://jestjs.io/docs/en/tutorial-react-native)\n- [Detox](https://github.com/wix/detox/)\n- [Appium](http://appium.io/)",
      "source_content_hash": "597dffe7c9dd6a7467174c094ffdac14cd74d76be5850c99cd635a7300b77c77",
      "node_type": "list",
      "translatable": true,
      "translations": {
        "zh-hant": "- [React 測試概述](https://reactjs.org/docs/testing.html)\n- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)\n- [Jest 文件](https://jestjs.io/docs/en/tutorial-react-native)\n- [Detox](https://github.com/wix/detox/)\n- [Appium](http://appium.io/)"
      }
    },
    {
      "segment_id": "d5eb9f27",
      "source_content": "---",
      "source_content_hash": "cb3f91d54eee30e53e35b2b99905f70f169ed549fd78909d3dac2defc9ed8d3b",
      "node_type": "thematicBreak",
      "translatable": true,
      "translations": {
        "zh-hant": "---"
      }
    },
    {
      "segment_id": "6085c028",
      "source_content": "_This guide originally authored and contributed in full by [Vojtech Novak](https://twitter.com/vonovak)._",
      "source_content_hash": "bce91170c78bc737c42d51636188ca19ff7b8a3782e7125fd12879f641008add",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-hant": "_本指南最初由 [Vojtech Novak](https://twitter.com/vonovak) 撰寫並完整貢獻。_"
      }
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-docs/version-0.70/testing-overview.md",
  "last_updated_timestamp": "2025-06-18T10:03:59.256522+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-hant": "d58bb94b6198579438f113c91bce780bce04647597e9b2f71f6bd0f4e74212a7"
  }
}